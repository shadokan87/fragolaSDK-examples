import { Store } from "./store";
import { Fragola, type ChatCompletionMessageParam, type DefineMetaData, type Tool } from "./fragola";
import type { ChatCompletionCreateParamsBase } from "openai/resources/chat/completions.js";
import type z from "zod";
import type { Prettify, StoreLike } from "./types";
import OpenAI from "openai/index.js";
import { type AgentEventId } from "./event";
import type { EventToolCall, EventUserMessage, EventModelInvocation, EventAiMessage } from "./eventDefault";
import type { EventAfterConversationUpdate, AfterStateUpdateCallback } from "./eventAfter";
import { type registeredEvent, type eventIdToCallback, EventMap } from "./extendedJS/events/EventMap";
import type { FragolaHook } from "@src/hook/index";
import type { ResponseFormatJSONSchema } from "openai/resources";
export type AgentState<TMetaData extends DefineMetaData<any> = {}> = {
    conversation: ChatCompletionMessageParam<TMetaData>[];
    stepCount: number;
    status: "idle" | "generating" | "waiting";
};
export type JsonOptions<T extends z.ZodTypeAny = z.ZodTypeAny> = {
    message: string;
    /** A Zod schema describing the expected JSON shape returned by the AI/tool */
    schema: T;
    /** prefer calling a tool instead of using the AI completion */
    preferToolCall?: boolean;
    /** optional model settings passthrough */
    modelSettings?: AgentOptions["modelSettings"];
};
/**
 * Options for controlling the agent's step execution behavior.
 *
 * @see {@link defaultStepOptions} for default values.
 */
export type StepOptions = Partial<{
    /** The maximum number of steps to execute in one call (default: 10). */
    maxStep: number;
    /** Wether or not to reset agent state `stepCount` after each user messages. `true` is recommanded for conversational agents.*/
    resetStepCountAfterUserMessage: boolean;
    skipToolString: string;
    /** Will override the agent model settings. `response_format` will always be ovrride when using `json` method*/
    modelSettings?: ModelSettings;
    /**
     * Execute the steps on a cloned agent using  so the original state is not changed.
     * When true the call runs on a {@link Agent.fork} (clone) and returns the clone's output.
     * Use for speculative execution, testing, or to extract structured output without
     * mutating the main agent.
     * @default false
     */
    fork: boolean;
}>;
/**
 * @typescript The default values for {@link StepOptions}.
 *
 * @property maxStep - Default: 10. The maximum number of steps to execute in one call.
 * @property unansweredToolBehaviour - Default: "answer". Determines how to handle unanswered tool calls.
 * @property skipToolString - Default: "(generation has been canceled, you may ignore this tool output)". The string to use when skipping a tool call.
 */
export declare const defaultStepOptions: StepOptions;
export type ModelSettings = Prettify<Omit<ChatCompletionCreateParamsBase, "messages" | "tools">>;
/**
 * Options for configuring the agent context.
 */
export interface AgentOptions {
    /** Optional settings for each step in the agent's process. */
    stepOptions?: StepOptions;
    /** The name assigned to the agent. */
    name: string;
    /** Whether to use the developer role for the agent (optional). */
    useDeveloperRole?: boolean;
    /** Instructions or guidelines for the agent's behavior. */
    instructions: string;
    /** Description of the agent, a detailed description is recommanded if used for orchestration or as a sub-agent */
    description: string;
    /** Optional array of tools available to the agent. */
    tools?: Tool<any>[];
    /** Model-specific settings excluding messages and tools. */
    modelSettings?: ModelSettings;
}
export type SetOptionsParams = Omit<AgentOptions, "name" | "initialConversation">;
export type CreateAgentOptions<TStore extends StoreLike<any> = {}> = {
    store?: Store<TStore>;
    /** Optional initial conversation history for the agent. */
    initialConversation?: OpenAI.ChatCompletionMessageParam[];
} & Prettify<AgentOptions>;
export type ResetParams = Prettify<Pick<Required<CreateAgentOptions>, "initialConversation">>;
declare const AGENT_FRIEND: unique symbol;
type ContextRaw = {
    appendMessages: Agent["appendMessages"];
    updateConversation: Agent["updateConversation"];
};
/**
 * Context of the agent which triggered the event or tool.
 */
export declare class AgentContext<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {
    #private;
    private _state;
    private _options;
    private _store;
    private _globalStore;
    private setInstructionsFn;
    private setOptionsFn;
    private stopFn;
    constructor(_state: AgentState<TMetaData>, _options: AgentOptions, _store: Store<TStore> | undefined, _globalStore: Store<TGlobalStore> | undefined, instance: Fragola, setInstructionsFn: (instructions: string) => void, setOptionsFn: (options: SetOptionsParams) => void, stopFn: () => Promise<void>, raw: ContextRaw);
    [AGENT_FRIEND]: {
        setState: (newState: AgentState) => void;
        setOptions: (newOptions: AgentOptions) => void;
    };
    /** The current state of the agent. */
    get state(): AgentState<TMetaData>;
    /** The configuration options for the agent context. */
    get options(): AgentOptions;
    get raw(): ContextRaw;
    /** Acess the agent's local store. */
    get store(): Store<TStore> | undefined;
    get instance(): Fragola<{}>;
    /** Returns the agent's local store casted as T. Recommanded when accessing the store from a tool */
    getStore<T extends StoreLike<any>>(): Store<T> | undefined;
    /** Access the global store shared across agents of the same Fragola instance. */
    get globalStore(): Store<TGlobalStore> | undefined;
    /** Returns the global store casted as T. Recommanded when accessing the global store from a tool */
    getGlobalStore<T extends StoreLike<any>>(): Store<T> | undefined;
    /**
     * Sets the current instructions for the agent.
     * @param instructions - The new instructions as a string.
     */
    setInstructions(instructions: string): void;
    /**
     * Updates the agent's options.
     * **note**: the `name` property is ommited
     * @param options - The new options to set, as a SetOptionsParams object.
     */
    setOptions(options: SetOptionsParams): void;
    stop(): Promise<void>;
}
type StepBy = Partial<{
    /** To execute only up to N steps even if `maxStep` is not hit*/
    by: number;
}>;
export type StepParams = StepBy & StepOptions;
export type UserMessageQuery = Prettify<Omit<OpenAI.Chat.ChatCompletionUserMessageParam, "role">> & {
    step?: StepParams;
};
export type JsonQuery<S extends z.ZodTypeAny = z.ZodTypeAny> = Prettify<UserMessageQuery & {
    /** Set to true to use tool calling to extract json instead of classic 'response_format' */
    preferToolCalling?: boolean;
    /** Zod schema describing the expected JSON shape for the response */
    schema: S;
    /** If set to true, `userMessage` events will not be applied for this query */
    ignoreUserMessageEvents?: boolean;
} & Omit<ResponseFormatJSONSchema.JSONSchema, "schema">>;
export type JsonResult<S extends z.ZodTypeAny = z.ZodTypeAny, TMetaData extends DefineMetaData<any> = {}> = {
    state: AgentState<TMetaData>;
} & z.SafeParseReturnType<unknown, z.infer<S>>;
declare const FORK_FRIEND: unique symbol;
export declare class Agent<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {
    #private;
    private opts;
    private globalStore;
    static defaultAgentState: AgentState;
    private openai;
    private paramsTools;
    private registeredEvents;
    private abortController;
    private stopRequested;
    private context;
    private hooks;
    constructor(opts: CreateAgentOptions<TStore>, globalStore: Store<TGlobalStore> | undefined, openai: OpenAI, forkOf: string | undefined, instance: Fragola, state?: AgentState<TMetaData>);
    private setRegisteredEvents;
    [FORK_FRIEND]: {
        setRegisteredEvents: (map: typeof this.registeredEvents) => void;
        getRegisteredEvents: () => EventMap<AgentEventId, registeredEvent<AgentEventId, TMetaData, TGlobalStore, TStore>[], TMetaData, TGlobalStore, TStore>;
    };
    get id(): string;
    get state(): AgentState<TMetaData>;
    fork(): Agent<TMetaData, TGlobalStore, TStore>;
    private toolsToModelSettingsTools;
    private appendMessages;
    private setIdle;
    private setGenerating;
    private setWaiting;
    private updateState;
    private updateConversation;
    /**
     * Updates the agent's options.
     * **Note**: Can only be called when agent status is "idle".
     * The `name` and `initialConversation` properties are omitted.
     *
     * @param options - The new options to set, as a SetOptionsParams object.
     * @throws {BadUsage} When called while agent is not idle (generating or waiting).
     */
    setOptions(options: SetOptionsParams): void;
    get options(): CreateAgentOptions<TStore>;
    private stepOptions;
    private validateStepOptions;
    step(stepParams?: StepParams): Promise<AgentState<TMetaData>>;
    resetStepCount(): void;
    reset(params?: ResetParams): void;
    /**
     * Stops the current agent execution.
     * This will abort any ongoing API calls and prevent further tool execution.
     */
    stop(): Promise<void>;
    private lastAiMessage;
    private createAgentContext;
    private setStepCount;
    private recursiveAgent;
    private modelSettings;
    json<S extends z.ZodTypeAny = z.ZodTypeAny>(query: JsonQuery<S>): Promise<JsonResult<S, TMetaData>>;
    userMessage(query: UserMessageQuery): Promise<AgentState>;
    private applyEvents;
    /**
     * Register a handler for a given event id.
     * Returns an unsubscribe function that removes the registered handler.
     *
     * @example
     * // listen to userMessage events
     * const off = agent.on('userMessage', (message, context) => {
     *   // inspect or transform the message
     *   return { ...message, content: message.content.trim() };
     * });
     * // later
     * off();
     */
    on<TEventId extends AgentEventId>(eventId: TEventId, callback: eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a tool call event handler.
     *
     * This handler is invoked when the agent needs to execute a tool. Handlers may return a value
     * that will be used as the tool result.
     *
     * @example
     * // simple tool handler that returns an object as result
     * agent.onToolCall(async (params, tool, context) => {
     *   // dynamic tools do not have a handler function, so we skip them
     *   if (params.handler == "dynamic") return skip();
     *   // do something with params and tool
     *   try {
     *      const result = await tool.handler(params);
     *      return { sucess: true, result }
     * } catch(e) {
     *      if (e extends Error)
     *      return { error: e.message }
     * }
     * });
     */
    onToolCall<TParams = Record<any, any>>(callback: EventToolCall<TParams, TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a handler that runs after the conversation is updated.
     *
     * After-event handlers do not return a value. Use these to persist state, emit metrics or side-effects.
     *
     * @example
     * agent.onAfterConversationUpdate((reason, context) => {
     *   // persist conversation to a DB or telemetry
     *   console.log('conversation updated because of', reason);
     *   context.getStore()?.value.lastSaved = Date.now();
     * });
     */
    onAfterConversationUpdate(callback: EventAfterConversationUpdate<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register an AI message event handler.
     *
     * Called when an assistant message is generated or streaming. Handlers may return a modified
     * message which will replace the message in the conversation.
     *
     * @example
     * agent.onAiMessage((message, isPartial, context) => {
     *   if (!isPartial && message.content.includes('debug')) {
     *     // modify final assistant message
     *      message.content += '(edited)';
     *   }
     *   return message;
     * });
     */
    onAiMessage(callback: EventAiMessage<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a user message event handler.
     *
     * Called when a user message is appended to the conversation. Handlers may return a modified
     * user message which will be used instead of the original.
     *
     * @example
     * agent.onUserMessage((message, context) => {
     *   // enrich user message with metadata
     *   return { ...message, content: message.content.trim() };
     * });
     */
    onUserMessage(callback: EventUserMessage<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a model invocation event handler.
     *
     * This handler wraps the model call. It receives a `callAPI` function to perform the request and
     * can return a modified assistant message. Handlers can also provide a `processChunk` function to
     * edit streaming chunks before they are applied to the partial assistant message.
     *
     * @example
     * // modify streaming chunks before they are applied
     * agent.onModelInvocation(async (callAPI, context) => {
     *   const processChunk: CallAPIProcessChuck = (chunk, partial) => {
     *     // e.g. redact sensitive tokens or append extra tokens
     *     chunck.choices[0].delta.content = '(modified)';
     *     // perform modifications on `modified` here
     *     return chunck;
     *   };
     *   // pass the processor to callAPI; it returns the final assistant message
     *   const aiMsg = await callAPI(processChunk);
     *   // post-process the final assistant message if needed
     *   return { ...aiMsg, content: aiMsg.content + '\n\n(checked)' };
     * });
     */
    onModelInvocation(callback: EventModelInvocation<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Register a handler that runs after the agent state is updated.
     *
     * After-state-update handlers do not return a value. Use these for side-effects such as metrics
     * or asynchronous persistence.
     *
     * @example
     * agent.onAfterStateUpdate((context) => {
     *   // e.g. emit metrics about step count
     *   console.log('stepCount', context.state.stepCount);
     * });
     */
    onAfterStateUpdate(callback: AfterStateUpdateCallback<TMetaData, TGlobalStore, TStore>): () => void;
    /**
     * Attach a hook to this agent.
     *
     * Hooks receive the agent instance and may register event handlers
     * or otherwise augment the agent's behavior.
     *
     * @param hook - A FragolaHook to attach to the agent
     * @returns The agent instance (chainable)
     *
     * @example
     * ```ts
     * import { fileSystemSave } from "@src/hookPreset";
     * const agent = fragola.agent({...}).use(fileSystemSave("./testHook"));
     * // agent is returned so additional configuration/calls can be chained
     * ```
     */
    use(hook: FragolaHook): this;
}
export type AgentAny = Agent<any, any, any>;
export {};
