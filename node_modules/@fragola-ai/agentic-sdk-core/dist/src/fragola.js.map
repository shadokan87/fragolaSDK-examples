{
  "version": 3,
  "sources": ["../../src/fragola.ts"],
  "sourcesContent": ["import z from \"zod\";\nimport { Agent, type AgentContext, type AgentOptions, type CreateAgentOptions, type JsonQuery } from \"./agent\";\nimport type { maybePromise } from \"./types\";\nimport type { ClientOptions } from \"openai/index.js\";\nimport OpenAI from \"openai/index.js\";\nimport type { Store } from \"./store\";\nimport { BadUsage } from \"./exceptions\";\n\nexport type ToolHandlerReturnTypeNonAsync = any[] | Record<any, any> | Function | number | bigint | boolean | string;\nexport type ToolHandlerReturnType = maybePromise<ToolHandlerReturnTypeNonAsync>;\nexport type AllowedMetaKeys = \"user\" | \"ai\" | \"tool\";\n\n/**\n * Restricts metadata definition to only \"user\", \"ai\", and \"tool\" keys.\n * Any other keys will be omitted from the resulting type.\n */\nexport type DefineMetaData<T extends Partial<Record<AllowedMetaKeys, any>>> = {\n    [K in keyof T as K extends AllowedMetaKeys ? K : never]: T[K]\n};\n\nexport type ChatCompletionUserMessageParam<MetaData extends { user?: any } = {}> = OpenAI.Chat.ChatCompletionUserMessageParam & { meta?: MetaData[\"user\"] };\n\nexport type ChatCompletionAssistantMessageParam<MetaData extends { ai?: any } = {}> = OpenAI.Chat.ChatCompletionAssistantMessageParam & { meta?: MetaData[\"ai\"] };\n\nexport type ChatCompletionToolMessageParam<MetaData extends { tool?: any } = {}> = OpenAI.Chat.ChatCompletionToolMessageParam & { meta?: MetaData[\"tool\"] };\n\nexport type MessageMeta<TMetaData extends DefineMetaData<any>, TKey extends AllowedMetaKeys> = TMetaData extends { [K in TKey]?: any } ? TMetaData[TKey] : never;\n\nexport type ChatCompletionMessageParam<TMetaData extends DefineMetaData<any> = {}> = ChatCompletionUserMessageParam<MessageMeta<TMetaData, \"user\">>\n    | ChatCompletionAssistantMessageParam<MessageMeta<TMetaData, \"ai\">>\n    | ChatCompletionToolMessageParam<MessageMeta<TMetaData, \"tool\">>\n    | OpenAI.Chat.Completions.ChatCompletionDeveloperMessageParam\n    | OpenAI.Chat.Completions.ChatCompletionSystemMessageParam\n    | OpenAI.Chat.Completions.ChatCompletionFunctionMessageParam\n    ;\n\nexport interface Tool<T extends z.ZodType<any, any> = any> {\n    /**\n     * The name of the tool.\n     */\n    name: string;\n    /**\n     * A detailed description of the tool's purpose.\n     */\n    description: string;\n    /**\n     * The function that handles the tool's logic, or the string \"dynamic\" for dynamic handlers.\n     */\n    handler: ((parameters: z.infer<T>, context: AgentContext<any, any>) => ToolHandlerReturnType) | \"dynamic\";\n    /**\n     * The Zod schema that validates the parameters for the tool.\n     */\n    schema?: T;\n}\n\nexport const tool = <T extends z.ZodType<any, any>>(params: Tool<T>) => params;\n\nexport function stripMeta<T extends object>(data: (T & { meta?: any }) | Array<T & { meta?: any }>) {\n    const _strip = (message: T & { meta?: any }) => {\n        const { meta, ...messageWithoutMeta } = message;\n        void meta;\n        return messageWithoutMeta;\n    };\n    if (Array.isArray(data))\n        return data.map(msg => _strip(msg));\n    return _strip(data);\n}\n\nexport const stripConversationMeta = (conversation: ChatCompletionMessageParam[]): OpenAI.ChatCompletionMessageParam[] => stripMeta(conversation) as OpenAI.ChatCompletionMessageParam[];\n\nexport const stripAiMessageMeta = (aiMessage: ChatCompletionAssistantMessageParam): OpenAI.ChatCompletionAssistantMessageParam => stripMeta(aiMessage) as OpenAI.ChatCompletionAssistantMessageParam;\n\nexport const stripUserMessageMeta = (userMessage: ChatCompletionUserMessageParam): OpenAI.ChatCompletionUserMessageParam => stripMeta(userMessage) as OpenAI.ChatCompletionUserMessageParam;\n\nexport const stripToolMessageMeta = (toolMessage: ChatCompletionToolMessageParam): OpenAI.ChatCompletionToolMessageParam => stripMeta(toolMessage) as OpenAI.ChatCompletionToolMessageParam;\n\nconst presetBadUsageMessage = `Nor 'preferedModel' or 'modelSettings.model' provided, 1 of both values are required for presets.`;\n\nexport type JsonOptions<T extends z.ZodTypeAny = z.ZodTypeAny> = {\n    message: string;\n    /** A Zod schema describing the expected JSON shape returned by the AI/tool */\n    schema: T;\n    /** prefer calling a tool instead of using the AI completion */\n    preferToolCall?: boolean;\n    /** optional model settings passthrough */\n    modelSettings?: AgentOptions[\"modelSettings\"];\n};\n\ntype PreferedModel = {\n    /**\n     * The model that will be used by default unless overridden in modelSettings.\n     */\n    model: string\n}\n\nexport class Fragola<TGlobalStore = {}> {\n    private openai: OpenAI;\n    constructor(private clientOptions: ClientOptions & PreferedModel, private globalStore: Store<TGlobalStore> | undefined = undefined) {\n        const opts = clientOptions ? (() => {\n            const copy = { ...clientOptions };\n            const { model, ...rest } = copy;\n            return rest;\n        })() : undefined;\n        this.openai = opts ? new OpenAI(opts) : new OpenAI();\n    }\n\n    agent<TMetaData extends DefineMetaData<any> = {}, TStore = {}>(opts: CreateAgentOptions<TStore>): Agent<TMetaData, TGlobalStore, TStore> {\n        return new Agent<TMetaData, TGlobalStore, TStore>(opts, this.globalStore, this.openai, undefined, this as Fragola<any>);\n    }\n\n    get options() {\n        return this.clientOptions;\n    }\n\n    async boolean(evaluate: string): Promise<boolean> {\n        const booleanSchema = z.object({\n            bool: z.boolean(),\n        });\n\n        const query: JsonQuery = {\n            name: \"evaluate_statement\",\n            content: evaluate,\n            description: \"provide your answer for the 'bool' value\",\n            schema: booleanSchema\n        };\n        const response = await this.json(query, {\n            name: \"BooleanEvaluator\",\n            description: \"Preset agent that outputs a single JSON field {bool: boolean} indicating truthiness of the 'evaluate' statement.\",\n            instructions: [\n                \"You evaluate structured checks of the form '<Claim>: <user_input>'.\",\n                \"Return ONLY a JSON object with the following shape: {\\\"bool\\\": boolean}.\",\n                \"No extra text, no markdown, no explanations.\",\n                \"Interpretation rule: 'bool' is true when the claim accurately describes <user_input>; otherwise false.\",\n                \"Ambiguous/unknown -> false.\",\n                \"Examples:\",\n                \"- Input: 'This topic is about mathematics: what is 2 + 2?' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This topic is about mathematics: write a love poem' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This input contains slurs: [slur], get out of here! You are not welcome' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This input contains slurs: have a great day' -> {\\\"bool\\\": false}\",\n                \"- Input: 'The topic is non professional: let's talk about weekend plans' -> {\\\"bool\\\": true}\",\n                \"- Input: 'The topic is non professional: how to deploy a Kubernetes cluster' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This input contains profanity: what the hell is this?' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This input contains profanity: good morning team' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This input contains PII: My SSN is 123-45-6789' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This input contains PII: The sky is blue' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This input is spam: CLICK HERE for FREE $$$ now!!!' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This input is spam: Could you review my PR?' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This input is NSFW: explicit sexual content' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This input is NSFW: how to write unit tests' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This topic is about politics: Presidential election polling analysis' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This topic is about politics: calculate the derivative of x^2' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This topic is about health: best practices for sleep hygiene' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This topic is about health: sorting algorithms' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This input promotes self-harm: I want to hurt myself' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This input promotes self-harm: I enjoy hiking' -> {\\\"bool\\\": false}\",\n                \"- Input: 'This input contains threats: I will hurt you' -> {\\\"bool\\\": true}\",\n                \"- Input: 'This input contains threats: Please take care' -> {\\\"bool\\\": false}\",\n            ].join(\"\\n\"),\n        });\n        return response.success ? response.data.bool : false;\n    }\n\n    async json<S extends z.ZodTypeAny = z.ZodTypeAny>(query: JsonQuery<S>, options: CreateAgentOptions | undefined = undefined): Promise<z.SafeParseReturnType<unknown, z.infer<S>>> {\n        if (!this.clientOptions?.model) {\n            throw new BadUsage(presetBadUsageMessage);\n        }\n\n        const { state, ...rest } = await this.agent(options ?? {\n            name: \"JsonExtraction\",\n            instructions: \"You will be given a user message with instructions to extract informations into json format.\",\n            description: \"Simple agent to extract data from text to json\"\n        }).json(query);\n        return rest;\n    }\n}"],
  "mappings": "AAAA,OAAOA,MAAO,MACd,OAAS,SAAAC,MAA4F,UAGrG,OAAOC,MAAY,kBAEnB,OAAS,YAAAC,MAAgB,eAiDlB,MAAMC,EAAuCC,GAAoBA,EAEjE,SAASC,EAA4BC,EAAwD,CAChG,MAAMC,EAAUC,GAAgC,CAC5C,KAAM,CAAE,KAAAC,EAAM,GAAGC,CAAmB,EAAIF,EAExC,OAAOE,CACX,EACA,OAAI,MAAM,QAAQJ,CAAI,EACXA,EAAK,IAAIK,GAAOJ,EAAOI,CAAG,CAAC,EAC/BJ,EAAOD,CAAI,CACtB,CAEO,MAAMM,EAAyBC,GAAoFR,EAAUQ,CAAY,EAEnIC,EAAsBC,GAA+FV,EAAUU,CAAS,EAExIC,EAAwBC,GAAuFZ,EAAUY,CAAW,EAEpIC,EAAwBC,GAAuFd,EAAUc,CAAW,EAE3IC,EAAwB,oGAmBvB,MAAMC,CAA2B,CAEpC,YAAoBC,EAAsDC,EAA+C,OAAW,CAAhH,mBAAAD,EAAsD,iBAAAC,EACtE,MAAMC,EAAOF,GAAiB,IAAM,CAChC,MAAMG,EAAO,CAAE,GAAGH,CAAc,EAC1B,CAAE,MAAAI,EAAO,GAAGC,CAAK,EAAIF,EAC3B,OAAOE,CACX,GAAG,EAAI,OACP,KAAK,OAASH,EAAO,IAAIvB,EAAOuB,CAAI,EAAI,IAAIvB,CAChD,CARQ,OAUR,MAA+DuB,EAA0E,CACrI,OAAO,IAAIxB,EAAuCwB,EAAM,KAAK,YAAa,KAAK,OAAQ,OAAW,IAAoB,CAC1H,CAEA,IAAI,SAAU,CACV,OAAO,KAAK,aAChB,CAEA,MAAM,QAAQI,EAAoC,CAC9C,MAAMC,EAAgB9B,EAAE,OAAO,CAC3B,KAAMA,EAAE,QAAQ,CACpB,CAAC,EAEK+B,EAAmB,CACrB,KAAM,qBACN,QAASF,EACT,YAAa,2CACb,OAAQC,CACZ,EACME,EAAW,MAAM,KAAK,KAAKD,EAAO,CACpC,KAAM,mBACN,YAAa,mHACb,aAAc,CACV,sEACA,yEACA,+CACA,yGACA,8BACA,YACA,+EACA,mFACA,uGACA,4EACA,6FACA,kGACA,qFACA,iFACA,8EACA,yEACA,kFACA,4EACA,2EACA,4EACA,oGACA,8FACA,4FACA,+EACA,oFACA,8EACA,4EACA,6EACJ,EAAE,KAAK;AAAA,CAAI,CACf,CAAC,EACD,OAAOC,EAAS,QAAUA,EAAS,KAAK,KAAO,EACnD,CAEA,MAAM,KAA4CD,EAAqBE,EAA0C,OAAgE,CAC7K,GAAI,CAAC,KAAK,eAAe,MACrB,MAAM,IAAI9B,EAASkB,CAAqB,EAG5C,KAAM,CAAE,MAAAa,EAAO,GAAGN,CAAK,EAAI,MAAM,KAAK,MAAMK,GAAW,CACnD,KAAM,iBACN,aAAc,+FACd,YAAa,gDACjB,CAAC,EAAE,KAAKF,CAAK,EACb,OAAOH,CACX,CACJ",
  "names": ["z", "Agent", "OpenAI", "BadUsage", "tool", "params", "stripMeta", "data", "_strip", "message", "meta", "messageWithoutMeta", "msg", "stripConversationMeta", "conversation", "stripAiMessageMeta", "aiMessage", "stripUserMessageMeta", "userMessage", "stripToolMessageMeta", "toolMessage", "presetBadUsageMessage", "Fragola", "clientOptions", "globalStore", "opts", "copy", "model", "rest", "evaluate", "booleanSchema", "query", "response", "options", "state"]
}
