import z from "zod";
import { Agent, type AgentContext, type AgentOptions, type CreateAgentOptions, type JsonQuery } from "./agent";
import type { maybePromise } from "./types";
import type { ClientOptions } from "openai/index.js";
import OpenAI from "openai/index.js";
import type { Store } from "./store";
export type ToolHandlerReturnTypeNonAsync = any[] | Record<any, any> | Function | number | bigint | boolean | string;
export type ToolHandlerReturnType = maybePromise<ToolHandlerReturnTypeNonAsync>;
export type AllowedMetaKeys = "user" | "ai" | "tool";
/**
 * Restricts metadata definition to only "user", "ai", and "tool" keys.
 * Any other keys will be omitted from the resulting type.
 */
export type DefineMetaData<T extends Partial<Record<AllowedMetaKeys, any>>> = {
    [K in keyof T as K extends AllowedMetaKeys ? K : never]: T[K];
};
export type ChatCompletionUserMessageParam<MetaData extends {
    user?: any;
} = {}> = OpenAI.Chat.ChatCompletionUserMessageParam & {
    meta?: MetaData["user"];
};
export type ChatCompletionAssistantMessageParam<MetaData extends {
    ai?: any;
} = {}> = OpenAI.Chat.ChatCompletionAssistantMessageParam & {
    meta?: MetaData["ai"];
};
export type ChatCompletionToolMessageParam<MetaData extends {
    tool?: any;
} = {}> = OpenAI.Chat.ChatCompletionToolMessageParam & {
    meta?: MetaData["tool"];
};
export type MessageMeta<TMetaData extends DefineMetaData<any>, TKey extends AllowedMetaKeys> = TMetaData extends {
    [K in TKey]?: any;
} ? TMetaData[TKey] : never;
export type ChatCompletionMessageParam<TMetaData extends DefineMetaData<any> = {}> = ChatCompletionUserMessageParam<MessageMeta<TMetaData, "user">> | ChatCompletionAssistantMessageParam<MessageMeta<TMetaData, "ai">> | ChatCompletionToolMessageParam<MessageMeta<TMetaData, "tool">> | OpenAI.Chat.Completions.ChatCompletionDeveloperMessageParam | OpenAI.Chat.Completions.ChatCompletionSystemMessageParam | OpenAI.Chat.Completions.ChatCompletionFunctionMessageParam;
export interface Tool<T extends z.ZodType<any, any> = any> {
    /**
     * The name of the tool.
     */
    name: string;
    /**
     * A detailed description of the tool's purpose.
     */
    description: string;
    /**
     * The function that handles the tool's logic, or the string "dynamic" for dynamic handlers.
     */
    handler: ((parameters: z.infer<T>, context: AgentContext<any, any>) => ToolHandlerReturnType) | "dynamic";
    /**
     * The Zod schema that validates the parameters for the tool.
     */
    schema?: T;
}
export declare const tool: <T extends z.ZodType<any, any>>(params: Tool<T>) => Tool<T>;
export declare function stripMeta<T extends object>(data: (T & {
    meta?: any;
}) | Array<T & {
    meta?: any;
}>): Omit<T & {
    meta?: any;
}, "meta"> | Omit<T & {
    meta?: any;
}, "meta">[];
export declare const stripConversationMeta: (conversation: ChatCompletionMessageParam[]) => OpenAI.ChatCompletionMessageParam[];
export declare const stripAiMessageMeta: (aiMessage: ChatCompletionAssistantMessageParam) => OpenAI.ChatCompletionAssistantMessageParam;
export declare const stripUserMessageMeta: (userMessage: ChatCompletionUserMessageParam) => OpenAI.ChatCompletionUserMessageParam;
export declare const stripToolMessageMeta: (toolMessage: ChatCompletionToolMessageParam) => OpenAI.ChatCompletionToolMessageParam;
export type JsonOptions<T extends z.ZodTypeAny = z.ZodTypeAny> = {
    message: string;
    /** A Zod schema describing the expected JSON shape returned by the AI/tool */
    schema: T;
    /** prefer calling a tool instead of using the AI completion */
    preferToolCall?: boolean;
    /** optional model settings passthrough */
    modelSettings?: AgentOptions["modelSettings"];
};
type PreferedModel = {
    /**
     * The model that will be used by default unless overridden in modelSettings.
     */
    model: string;
};
export declare class Fragola<TGlobalStore = {}> {
    private clientOptions;
    private globalStore;
    private openai;
    constructor(clientOptions: ClientOptions & PreferedModel, globalStore?: Store<TGlobalStore> | undefined);
    agent<TMetaData extends DefineMetaData<any> = {}, TStore = {}>(opts: CreateAgentOptions<TStore>): Agent<TMetaData, TGlobalStore, TStore>;
    get options(): ClientOptions & PreferedModel;
    boolean(evaluate: string): Promise<boolean>;
    json<S extends z.ZodTypeAny = z.ZodTypeAny>(query: JsonQuery<S>, options?: CreateAgentOptions | undefined): Promise<z.SafeParseReturnType<unknown, z.infer<S>>>;
}
export {};
