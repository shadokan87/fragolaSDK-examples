{
  "version": 3,
  "sources": ["../../src/agent.ts"],
  "sourcesContent": ["import { createStore, Store } from \"./store\"\nimport { Fragola, stripUserMessageMeta, type ChatCompletionMessageParam, type ChatCompletionUserMessageParam, type DefineMetaData, type Tool } from \"./fragola\"\nimport type { ChatCompletionCreateParamsBase } from \"openai/resources/chat/completions.js\"\nimport { streamChunkToMessage, isAsyncFunction, isSkipEvent, skipEventFallback } from \"./utils\"\nimport { BadUsage, FragolaError, JsonModeError, MaxStepHitError } from \"./exceptions\"\nimport type z from \"zod\";\nimport { z as zod } from \"zod\";\nimport type { maybePromise, Prettify, StoreLike } from \"./types\"\nimport OpenAI from \"openai/index.js\"\nimport { type AgentEventId, type EventDefaultCallback } from \"./event\"\nimport type { CallAPI, CallAPIProcessChuck, EventToolCall, EventUserMessage, EventModelInvocation, EventAiMessage } from \"./eventDefault\";\nimport { nanoid } from \"nanoid\"\nimport type { EventAfterConversationUpdate, AfterStateUpdateCallback, conversationUpdateReason } from \"./eventAfter\"\nimport { type registeredEvent, type eventIdToCallback, EventMap } from \"./extendedJS/events/EventMap\"\nimport type { FragolaHook } from \"@src/hook/index\";\nimport { zodToJsonSchema } from \"openai/_vendor/zod-to-json-schema/zodToJsonSchema.js\"\nimport type { ResponseFormatJSONSchema } from \"openai/resources\"\n\nexport type AgentState<TMetaData extends DefineMetaData<any> = {}> = {\n    conversation: ChatCompletionMessageParam<TMetaData>[],\n    stepCount: number,\n    status: \"idle\" | \"generating\" | \"waiting\",\n}\n\nexport type JsonOptions<T extends z.ZodTypeAny = z.ZodTypeAny> = {\n    message: string;\n    /** A Zod schema describing the expected JSON shape returned by the AI/tool */\n    schema: T;\n    /** prefer calling a tool instead of using the AI completion */\n    preferToolCall?: boolean;\n    /** optional model settings passthrough */\n    modelSettings?: AgentOptions[\"modelSettings\"];\n};\n\n/**\n * Options for controlling the agent's step execution behavior.\n *\n * @see {@link defaultStepOptions} for default values.\n */\nexport type StepOptions = Partial<{\n    /** The maximum number of steps to execute in one call (default: 10). */\n    maxStep: number,\n    /** Wether or not to reset agent state `stepCount` after each user messages. `true` is recommanded for conversational agents.*/\n    resetStepCountAfterUserMessage: boolean,\n\n    //TODO: unanswered tool behaviour fields\n    // /** Determines how to handle unanswered tool calls: `answer` to process them, `skip` to ignore (default: \"answer\"). */\n    // unansweredToolBehaviour: \"answer\" | \"skip\",\n    // /** The string to use when skipping a tool call (default: \"(generation has been canceled, you may ignore this tool output)\"). */\n    skipToolString: string,\n    /** Will override the agent model settings. `response_format` will always be ovrride when using `json` method*/\n    modelSettings?: ModelSettings,\n    //@ts-nocheck\n    /**\n     * Execute the steps on a cloned agent using  so the original state is not changed.\n     * When true the call runs on a {@link Agent.fork} (clone) and returns the clone's output.\n     * Use for speculative execution, testing, or to extract structured output without\n     * mutating the main agent.\n     * @default false\n     */\n    fork: boolean,\n}>;\n\n/**\n * @typescript The default values for {@link StepOptions}.\n *\n * @property maxStep - Default: 10. The maximum number of steps to execute in one call.\n * @property unansweredToolBehaviour - Default: \"answer\". Determines how to handle unanswered tool calls.\n * @property skipToolString - Default: \"(generation has been canceled, you may ignore this tool output)\". The string to use when skipping a tool call.\n */\nexport const defaultStepOptions: StepOptions = {\n    maxStep: 10,\n    resetStepCountAfterUserMessage: true,\n    // unansweredToolBehaviour: \"answer\",\n    // skipToolString: \"Info: this too execution has been canceled. Do not assume it has been processed and inform the user that you are aware of it.\"\n}\n\nexport type ModelSettings = Prettify<Omit<ChatCompletionCreateParamsBase, \"messages\" | \"tools\">>;\n\n/**\n * Options for configuring the agent context.\n */\nexport interface AgentOptions {\n    /** Optional settings for each step in the agent's process. */\n    stepOptions?: StepOptions,\n    /** The name assigned to the agent. */\n    name: string,\n    /** Whether to use the developer role for the agent (optional). */\n    useDeveloperRole?: boolean,\n    /** Instructions or guidelines for the agent's behavior. */\n    instructions: string,\n    /** Description of the agent, a detailed description is recommanded if used for orchestration or as a sub-agent */\n    description: string,\n    /** Optional array of tools available to the agent. */\n    tools?: Tool<any>[],\n    /** Model-specific settings excluding messages and tools. */\n    modelSettings?: ModelSettings\n} //TODO: better comment for stepOptions with explaination for each fields\n\nexport type SetOptionsParams = Omit<AgentOptions, \"name\" | \"initialConversation\">;\n\nexport type CreateAgentOptions<TStore extends StoreLike<any> = {}> = {\n    store?: Store<TStore>,\n    /** Optional initial conversation history for the agent. */\n    initialConversation?: OpenAI.ChatCompletionMessageParam[],\n} & Prettify<AgentOptions>;\n\nexport type ResetParams = Prettify<Pick<Required<CreateAgentOptions>, \"initialConversation\">>;\n\nconst AGENT_FRIEND = Symbol('AgentAccess');\n\ntype ContextRaw = {\n    appendMessages: Agent[\"appendMessages\"],\n    updateConversation: Agent[\"updateConversation\"]\n}\n/**\n * Context of the agent which triggered the event or tool.\n */\nexport class AgentContext<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {\n    #raw: ContextRaw\n    #instance: Fragola\n    constructor(\n        private _state: AgentState<TMetaData>,\n        private _options: AgentOptions,\n        private _store: Store<TStore> | undefined,\n        private _globalStore: Store<TGlobalStore> | undefined,\n        instance: Fragola,\n        private setInstructionsFn: (instructions: string) => void,\n        private setOptionsFn: (options: SetOptionsParams) => void,\n        private stopFn: () => Promise<void>,\n        raw: ContextRaw,\n    ) {\n        this.#instance = instance,\n        this.#raw = raw;\n    }\n\n    [AGENT_FRIEND] = {\n        setState: (newState: AgentState) => {\n            this._state = newState;\n        },\n        setOptions: (newOptions: AgentOptions) => {\n            this._options = newOptions;\n        },\n    };\n\n    /** The current state of the agent. */\n    get state() {\n        return this._state;\n    }\n\n    /** The configuration options for the agent context. */\n    get options() {\n        return this._options;\n    }\n\n    get raw() {\n        return this.#raw\n    }\n\n    /** Acess the agent's local store. */\n    get store() {\n        return this._store as Store<TStore> | undefined;\n    }\n\n    get instance() { return this.#instance }\n\n    /** Returns the agent's local store casted as T. Recommanded when accessing the store from a tool */\n    getStore<T extends StoreLike<any>>(): Store<T> | undefined { return this._store ? this._store as unknown as Store<T> : undefined }\n\n    /** Access the global store shared across agents of the same Fragola instance. */\n    get globalStore() {\n        return this._globalStore as Store<TGlobalStore> | undefined;\n    }\n\n    /** Returns the global store casted as T. Recommanded when accessing the global store from a tool */\n    getGlobalStore<T extends StoreLike<any>>(): Store<T> | undefined { return this._store ? this._store as unknown as Store<T> : undefined }\n\n    /**\n     * Sets the current instructions for the agent.\n     * @param instructions - The new instructions as a string.\n     */\n    setInstructions(instructions: string) {\n        this.setInstructionsFn(instructions);\n    }\n\n    /**\n     * Updates the agent's options.\n     * **note**: the `name` property is ommited\n     * @param options - The new options to set, as a SetOptionsParams object.\n     */\n    setOptions(options: SetOptionsParams) {\n        this.setOptionsFn(options);\n    }\n\n    async stop() {\n        return await this.stopFn();\n    }\n}\n\n// export interface agentRawMethods {\n//     setIdle: () => Promise<void>,\n//     setWaiting: () => Promise<void>,\n//     setGenerating: () => Promise<void>,\n//     dispatchState: (state: AgentState<any>) => Promise<void>,\n// }\n\n// export class AgentRawContext<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> extends AgentContext<TMetaData, TGlobalStore, TStore> {\n//     constructor(\n//         _state: AgentState<TMetaData>,\n//         _options: AgentOptions,\n//         _store: Store<TStore> | undefined,\n//         _globalStore: Store<TGlobalStore> | undefined,\n//         setInstructionsFn: (instructions: string) => void,\n//         setOptionsFn: (options: SetOptionsParams) => void,\n//         stopFn: () => Promise<void>,\n//         private rawMethods: agentRawMethods\n//     ) {\n//         super(_state, _options, _store, _globalStore, setInstructionsFn, setOptionsFn, stopFn);\n//     }\n\n//     get raw() {\n//         return this.rawMethods;\n//     }\n// }\n\ntype StepBy = Partial<{\n    /** To execute only up to N steps even if `maxStep` is not hit*/\n    by: number,\n}>;\n\nexport type StepParams = StepBy & StepOptions;\n\nexport type UserMessageQuery = Prettify<Omit<OpenAI.Chat.ChatCompletionUserMessageParam, \"role\">> & { step?: StepParams };\n\nexport type JsonQuery<S extends z.ZodTypeAny = z.ZodTypeAny> = Prettify<UserMessageQuery & {\n    /** Set to true to use tool calling to extract json instead of classic 'response_format' */\n    preferToolCalling?: boolean\n    /** Zod schema describing the expected JSON shape for the response */\n    schema: S,\n    /** If set to true, `userMessage` events will not be applied for this query */\n    ignoreUserMessageEvents?: boolean,\n} & Omit<ResponseFormatJSONSchema.JSONSchema, \"schema\">>;\n\nexport type JsonResult<S extends z.ZodTypeAny = z.ZodTypeAny, TMetaData extends DefineMetaData<any> = {}> = {\n    state: AgentState<TMetaData>\n} & z.SafeParseReturnType<unknown, z.infer<S>>;\n\ntype ConversationUpdateParams = {\n    reason: conversationUpdateReason\n}\n\ntype ApplyAfterConversationUpdateParams = ConversationUpdateParams;\n\ntype applyEventParams<K extends AgentEventId> =\n    K extends \"after:conversationUpdate\" ? ApplyAfterConversationUpdateParams :\n    K extends \"conversationUpdate\" ? ConversationUpdateParams :\n    never;\n\nconst FORK_FRIEND = Symbol(\"fork_friend\");\n\nexport class Agent<TMetaData extends DefineMetaData<any> = {}, TGlobalStore extends StoreLike<any> = {}, TStore extends StoreLike<any> = {}> {\n    public static defaultAgentState: AgentState = {\n        conversation: [],\n        stepCount: 0,\n        status: \"idle\"\n    }\n\n    private openai: OpenAI;\n    private paramsTools: ChatCompletionCreateParamsBase[\"tools\"] = [];\n    private registeredEvents: EventMap<AgentEventId, registeredEvent<AgentEventId, TMetaData, TGlobalStore, TStore>[], TMetaData, TGlobalStore, TStore> = new EventMap(() => this.context)\n    // private registeredEvents: Map<AgentEventId, registeredEvent<AgentEventId, TMetaData, TGlobalStore, TStore>[]> = new Map();\n    private abortController: AbortController | undefined = undefined;\n    private stopRequested: boolean = false;\n    private context: AgentContext<TMetaData, TGlobalStore, TStore>;\n    private hooks: FragolaHook[] = [];\n    #state: AgentState<TMetaData>;\n    #id: string;\n    #forkOf: string | undefined = undefined;\n    #instance: Fragola\n\n    constructor(\n        private opts: CreateAgentOptions<TStore>,\n        private globalStore: Store<TGlobalStore> | undefined = undefined,\n        openai: OpenAI,\n        forkOf: string | undefined = undefined,\n        instance: Fragola,\n        state = Agent.defaultAgentState as AgentState<TMetaData>,\n    ) {\n\n        this.#id = nanoid();\n        this.#state = state; \n        this.#forkOf = forkOf;\n        this.#instance = instance;\n        this.context = this.createAgentContext();\n        this.openai = openai;\n\n        this.toolsToModelSettingsTools();\n        if (opts.initialConversation != undefined)\n            this.#state.conversation = structuredClone(opts.initialConversation);\n        if (!opts.stepOptions)\n            this.opts[\"stepOptions\"] = defaultStepOptions;\n        else {\n            this.opts[\"stepOptions\"] = {\n                ...defaultStepOptions,\n                ...opts.stepOptions\n            }\n            this.validateStepOptions(this.opts.stepOptions);\n        }\n    }\n\n    private setRegisteredEvents = (map: typeof this.registeredEvents) => {\n        this.registeredEvents = map;\n    }\n\n    [FORK_FRIEND] = {\n        setRegisteredEvents: this.setRegisteredEvents,\n        getRegisteredEvents: () => this.registeredEvents\n    }\n\n    get id() {\n        return this.#id\n    }\n\n    get state() { return this.#state };\n\n    fork() {\n        const clonedOpts = structuredClone(this.opts);\n        if (this.opts.store) {\n            delete clonedOpts.store;\n            clonedOpts[\"store\"] = createStore(this.opts.store.value);\n        }\n\n        const clonedState = structuredClone(this.#state);\n        const forked = new Agent<TMetaData, TGlobalStore, TStore>(\n            clonedOpts,\n            this.globalStore,\n            this.openai,\n            this.#id,\n            this.#instance,\n            clonedState,\n        );\n\n        this.hooks.forEach(hook => forked.use(hook));\n        const forkedRegisteredEvents = forked[FORK_FRIEND].getRegisteredEvents();\n\n        if (this.registeredEvents.size !== 0) {\n            // Build merged entries starting from any events already present on the forked agent\n            const mergedEntries: [AgentEventId, registeredEvent<AgentEventId, TMetaData, TGlobalStore, TStore>[]][] = [];\n\n            // Copy existing fork events (if any) to mergedEntries\n            for (const [k, v] of forkedRegisteredEvents.entries()) {\n                mergedEntries.push([k, v.map(e => ({ ...e }))]);\n            }\n\n            // Merge events from the original agent, but skip events whose id already exists in the fork\n            for (const [k, v] of this.registeredEvents.entries()) {\n                const existing = mergedEntries.find(([key]) => key === k);\n                if (existing) {\n                    const existingIds = new Set(existing[1].map(e => e.id));\n                    const toAdd = v\n                        .filter(ev => !existingIds.has(ev.id))\n                        .map(ev => ({ ...ev }));\n                    existing[1].push(...toAdd);\n                } else {\n                    mergedEntries.push([k, v.map(ev => ({ ...ev }))]);\n                }\n            }\n\n            const cloneRegisteredEvents = new EventMap(() => forked.context, mergedEntries);\n            forked[FORK_FRIEND].setRegisteredEvents(cloneRegisteredEvents);\n        }\n        return forked;\n    }\n\n    // async raw(callback: AgentRaw<TMetaData, TGlobalStore, TStore>) {\n    //     const rawContext = new AgentRawContext(this.#state,\n    //         this.opts,\n    //         this.opts.store as Store<TStore> | undefined,\n    //         this.globalStore as Store<TGlobalStore> | undefined,\n    //         (instructions) => {\n    //             this.opts[\"instructions\"] = instructions;\n    //         },\n    //         (options) => {\n    //             this.opts = { ...options, name: this.opts.name, store: this.opts.store }\n    //         },\n    //         async () => await this.stop(), {\n    //         setGenerating: this.setGenerating,\n    //         setIdle: this.setIdle,\n    //         setWaiting: this.setWaiting,\n    //         dispatchState: async (state: AgentState<any>) => {\n    //             this.updateState(() => state)\n    //         }\n    //     });\n\n    //     if (isAsyncFunction(callback)) {\n    //         const newState = await callback(this.openai, rawContext);\n    //         this.updateState(() => newState);\n    //     } else {\n    //         const newState = callback(this.openai, rawContext) as Awaited<ReturnType<typeof callback>>;\n    //         this.updateState(() => newState);\n    //     }\n    //     return this.#state\n    // }\n\n    private toolsToModelSettingsTools() {\n        const result: ChatCompletionCreateParamsBase[\"tools\"] = [];\n        this.opts.tools?.forEach(tool => {\n            result.push({\n                type: \"function\",\n                function: {\n                    name: tool.name,\n                    description: tool.description,\n                    parameters: tool.schema ? zodToJsonSchema(tool.schema) : undefined\n                }\n\n            })\n        });\n        this.paramsTools = result;\n    }\n\n    private async appendMessages(messages: OpenAI.ChatCompletionMessageParam[], replaceLast: boolean = false, reason: conversationUpdateReason) {\n        await this.updateConversation((prev) => {\n            if (replaceLast)\n                return [...prev.slice(0, -1), ...messages];\n            return [...prev, ...messages]\n        }, reason);\n    }\n\n    private async setIdle() { await this.updateState(prev => ({ ...prev, status: \"idle\" })) }\n    private async setGenerating() { await this.updateState(prev => ({ ...prev, status: \"generating\" })) }\n    private async setWaiting() { await this.updateState(prev => ({ ...prev, status: \"waiting\" })) }\n\n\n    private async updateState(callback: (prev: AgentState<TMetaData>) => AgentState<TMetaData>) {\n        this.#state = callback(this.#state);\n        this.context[AGENT_FRIEND].setState(this.#state);\n        await this.applyEvents(\"after:stateUpdate\", null);\n    }\n\n    private async updateConversation(callback: (prev: AgentState<TMetaData>[\"conversation\"]) => AgentState<TMetaData>[\"conversation\"], reason: conversationUpdateReason) {\n        await this.updateState((prev) => ({ ...prev, conversation: callback(this.#state.conversation) }));\n        await this.applyEvents(\"after:conversationUpdate\", { reason });\n    }\n\n    /**\n     * Updates the agent's options.\n     * **Note**: Can only be called when agent status is \"idle\". \n     * The `name` and `initialConversation` properties are omitted.\n     * \n     * @param options - The new options to set, as a SetOptionsParams object.\n     * @throws {BadUsage} When called while agent is not idle (generating or waiting).\n     */\n    setOptions(options: SetOptionsParams) {\n        if (this.#state.status !== \"idle\") {\n            throw new BadUsage(\n                `Cannot change options while agent is '${this.#state.status}'. ` +\n                `Options can only be changed when agent status is 'idle'.`\n            );\n        }\n        this.opts = { ...this.opts, ...options };\n        this.context[AGENT_FRIEND].setOptions({ ...this.context.options, ...options });\n        this.toolsToModelSettingsTools();\n\n    }\n\n    get options() { return this.opts }\n\n    private stepOptions() { return this.opts.stepOptions as Required<StepOptions> }\n\n    private validateStepOptions(stepOptions: StepOptions | undefined) {\n        if (!stepOptions)\n            return;\n        const { maxStep } = stepOptions;\n        if (maxStep != undefined) {\n            if (maxStep <= 0)\n                throw new BadUsage(`field 'maxStep' of 'StepOptions' cannot be less than or equal to 0. Received '${maxStep}'`)\n        }\n    }\n\n    async step(stepParams?: StepParams) {\n        if (this.stopRequested) {\n            this.abortController = undefined;\n            this.stopRequested = false\n        }\n        let overrideStepOptions: StepOptions | undefined = undefined;\n        if (stepParams) {\n            const { by, ...rest } = stepParams;\n            if (by != undefined && by <= 0)\n                throw new BadUsage(`field 'by' of 'stepParams' cannot be less than or equal to 0. Received '${by}'`);\n            if (!rest || Object.keys(rest).length != 0)\n                overrideStepOptions = rest;\n        }\n        if (overrideStepOptions)\n            this.validateStepOptions(overrideStepOptions);\n        const stepOptions: Required<StepOptions> = overrideStepOptions ? { ...defaultStepOptions, ...overrideStepOptions } as Required<StepOptions> : this.stepOptions();\n        if (this.#state.conversation.length != 0)\n            await this.recursiveAgent(stepOptions, () => {\n                if (stepParams?.by != undefined)\n                    return this.#state.stepCount == (this.#state.stepCount + stepParams.by);\n                return false;\n            }).finally(() => {\n                this.abortController = undefined;\n                this.stopRequested = false;\n            });\n        return this.#state;\n    }\n\n    resetStepCount() {\n        this.#state.stepCount = 0;\n    }\n\n    reset(params: ResetParams = { initialConversation: [] }) {\n        if (this.#state.status != \"idle\") {\n            throw new BadUsage(\n                `Cannot reset while agent is '${this.#state.status}'. ` +\n                `Agent can only be reset when agent status is 'idle'.`\n            );\n        }\n        this.updateState(() => ({\n            status: \"idle\",\n            conversation: params.initialConversation,\n            stepCount: 0\n        }));\n    }\n\n    /**\n     * Stops the current agent execution.\n     * This will abort any ongoing API calls and prevent further tool execution.\n     */\n    async stop() {\n        this.stopRequested = true;\n        if (this.abortController) {\n            this.abortController.abort();\n        }\n    }\n\n    private lastAiMessage(conversation: OpenAI.ChatCompletionMessageParam[]): OpenAI.ChatCompletionAssistantMessageParam | undefined {\n        for (let i = conversation.length - 1; i >= 0; i--) {\n            const msg = conversation[i];\n            if (msg.role === \"assistant\") {\n                return msg;\n            }\n        }\n        return undefined;\n    }\n\n    private createAgentContext<TM extends DefineMetaData<any> = TMetaData, TGS extends StoreLike<any> = TGlobalStore, TS extends StoreLike<any> = TStore>(): AgentContext<TM, TGS, TS> {\n        return new AgentContext<TM, TGS, TS>(\n            this.#state,\n            this.opts,\n            this.opts.store as Store<TS> | undefined,\n            this.globalStore as Store<TGS> | undefined,\n            this.#instance,\n            (instructions) => {\n                this.opts[\"instructions\"] = instructions;\n            },\n            (options) => {\n                this.opts = { ...options, name: this.opts.name, store: this.opts.store }\n            },\n            async () => await this.stop(),\n            {\n                appendMessages: (...args: Parameters<typeof this.appendMessages>) => this.appendMessages(...args),\n                updateConversation: (...args: Parameters<typeof this.updateConversation>) => this.updateConversation(...args)\n            }\n        );\n    }\n\n    private setStepCount(value: number) {\n        this.updateState((prev) => {\n            return {\n                ...prev,\n                stepCount: value\n            }\n        });\n    }\n\n    private async recursiveAgent(stepOptions: Required<StepOptions>, stop: () => boolean, iter = 0): Promise<void> {\n        // Check if stop was requested\n        if (this.stopRequested) {\n            return;\n        }\n\n        if (stepOptions.resetStepCountAfterUserMessage) {\n            if (this.#state.conversation.at(-1)?.role == \"user\")\n                this.setStepCount(0);\n        }\n        if (this.#state.stepCount == stepOptions.maxStep)\n            throw new MaxStepHitError(``);\n\n        this.abortController = new AbortController();\n\n        const lastMessage: OpenAI.ChatCompletionMessageParam | undefined = this.#state.conversation.at(-1);\n        let aiMessage: OpenAI.ChatCompletionAssistantMessageParam;\n        let lastAiMessage: OpenAI.ChatCompletionAssistantMessageParam | undefined = undefined;\n        let toolCalls: OpenAI.Chat.Completions.ChatCompletionMessageToolCall[] = [];\n\n        const shouldGenerate: boolean = (() => {\n            if (lastMessage?.role == \"user\")\n                return true;\n            if (lastMessage?.role == \"tool\") {\n                lastAiMessage = this.lastAiMessage(this.#state.conversation);\n                if (!lastAiMessage)\n                    throw new FragolaError(\"Invalid conversation, found 'tool' role without previous 'assistant' role.\");\n                if (!lastAiMessage.tool_calls)\n                    throw new FragolaError(\"Invalid conversation, found 'tool' role but 'tool_calls' is empty in previous 'assistant' role.\");\n\n                // Some tool calls may be already answered, we filter them out\n                toolCalls = lastAiMessage.tool_calls.filter(toolCall => {\n                    return !this.#state.conversation.some(message => message.role == \"tool\" && message.tool_call_id == toolCall.id)\n                });\n                // Generation can happen only if all tool_calls have been answered, if not the case, tool calls will be answered and the generation can happen in the next recursive turn\n                return toolCalls.length == 0;\n            }\n            return false;\n        })();\n\n        if (shouldGenerate) {\n            const EmodelInvocation = this.registeredEvents.get(\"modelInvocation\");\n            const defaultProcessChunck: CallAPIProcessChuck = (chunck) => chunck;\n            const defaultModelSettings: ModelSettings = stepOptions.modelSettings ?? this.modelSettings();\n\n            const callAPI: CallAPI = async (processChunck, modelSettings, clientOpts) => {\n                const _processChunck = processChunck || defaultProcessChunck;\n                const _modelSettings = modelSettings || defaultModelSettings;\n                const openai = clientOpts ? new OpenAI(clientOpts) : this.openai;\n\n                const role: ChatCompletionCreateParamsBase[\"messages\"][0][\"role\"] = this.opts.useDeveloperRole ? \"developer\" : \"system\";\n                const requestBody: ChatCompletionCreateParamsBase = {\n                    ..._modelSettings,\n                    messages: [{ role, content: this.opts.instructions }, ...this.#state.conversation]\n                };\n                if (this.paramsTools?.length)\n                    requestBody[\"tools\"] = this.paramsTools;\n\n                this.setGenerating();\n                const response = await openai.chat.completions.create(requestBody, { signal: this.abortController!.signal });\n\n                // Handle streaming vs non-streaming\n                if (Symbol.asyncIterator in response) {\n                    let partialMessage: Partial<OpenAI.Chat.ChatCompletionMessageParam> = {};\n                    let replaceLast = false;\n\n                    for await (const chunck of response) {\n                        if (_processChunck.constructor.name == \"AsyncFunction\") {\n                            const _chunck = await _processChunck(chunck, partialMessage as typeof aiMessage);\n                            partialMessage = streamChunkToMessage(_chunck, partialMessage);\n                        } else {\n                            const _chunck = _processChunck(chunck, partialMessage as typeof aiMessage);\n                            partialMessage = streamChunkToMessage(_chunck as OpenAI.ChatCompletionChunk, partialMessage);\n                        }\n                        const updateReason: conversationUpdateReason = !chunck.choices[0].finish_reason ? \"partialAiMessage\" : \"AiMessage\";\n                        const partialMessageFinal = await this.registeredEvents.handleAiMessage(partialMessage as typeof aiMessage, updateReason == \"partialAiMessage\");\n                        await this.appendMessages([partialMessageFinal as OpenAI.Chat.ChatCompletionMessageParam], replaceLast, updateReason);\n                        if (!replaceLast) this.setStepCount(this.#state.stepCount + 1);\n                        replaceLast = true;\n                    }\n                    this.abortController = undefined;\n                    aiMessage = partialMessage as typeof aiMessage;\n                } else {\n                    this.abortController = undefined;\n                    aiMessage = response.choices[0].message as typeof aiMessage;\n                    await this.appendMessages([aiMessage], false, \"AiMessage\");\n                    this.setStepCount(this.#state.stepCount + 1);\n                }\n                if (aiMessage.role == \"assistant\" && aiMessage.tool_calls && aiMessage.tool_calls.length)\n                    toolCalls = aiMessage.tool_calls;\n                return aiMessage;\n            }\n            if (EmodelInvocation) {\n                for (const event of EmodelInvocation) {\n                    const params: Parameters<EventModelInvocation<TMetaData, TGlobalStore, TStore>> = [callAPI, this.context];\n                    const callback = event.callback as EventModelInvocation<TMetaData, TGlobalStore, TStore>;\n                    aiMessage = await skipEventFallback(await callback(...params), callAPI);\n                }\n            } else\n                await callAPI();\n        } else if (lastMessage?.role == \"assistant\" && lastMessage.tool_calls && lastMessage.tool_calls.length) { // Last message is 'assistant' role without generation required, assign tool calls if any\n            toolCalls = lastMessage.tool_calls;\n        }\n\n        // Handle tool calls if present\n        if (toolCalls.length > 0) {\n            await this.setWaiting();\n            for (const toolCall of toolCalls) {\n                // Check if stop was requested before processing each tool\n                if (this.stopRequested) {\n                    break;\n                }\n\n                // Find tool in options that matches the tool requested by last ai message\n                const tool = this.opts.tools?.find(tool => tool.name == toolCall.function.name);\n                if (!tool)\n                    throw new FragolaError(`Tool ${toolCall.function.name} missing`);\n\n                let paramsParsed: z.SafeParseReturnType<any, any> | undefined;\n                if (tool.schema) {\n                    paramsParsed = (tool.schema as z.Schema).safeParse(JSON.parse(toolCall.function.arguments));\n                    if (!paramsParsed.success) {\n                        //TODO: implement retry system for bad arguments\n                        throw new FragolaError(\"Tool arguments parsing fail\");\n                    }\n                }\n                const toolCallEvents = this.registeredEvents.get(\"toolCall\");\n                const content = await (async () => {\n                    eventProcessing: {\n                        if (!toolCallEvents) {\n                            if (tool.handler == \"dynamic\")\n                                throw new BadUsage(`Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result.`);\n                            break eventProcessing;\n                        }\n                        for (let i = 0; i < toolCallEvents.length; i++) {\n                            const _event = toolCallEvents[i];\n                            const result = isAsyncFunction(_event.callback) ? await _event.callback(paramsParsed?.data, tool as any, this.context)\n                                : _event.callback(paramsParsed?.data, tool as any, this.context);\n                            if (isSkipEvent(result)) {\n                                continue;\n                            }\n                            return result;\n                        }\n                        if (tool.handler == \"dynamic\")\n                            throw new BadUsage(`Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result. (one or more events were found but returned 'skip')`);\n                    }\n                    // Default tool behavior (executed after breaking from eventProcessing)\n                    return isAsyncFunction(tool.handler) ? await tool.handler(paramsParsed?.data, this.context as any) : tool.handler(paramsParsed?.data, this.context as any);\n                })();\n\n                const contentToString = (content: unknown) => {\n                    switch (typeof content) {\n                        case \"string\":\n                            return content;\n                        case \"function\":\n                            return (content as Function).toString();\n                        case \"undefined\":\n                        case \"number\":\n                        case \"boolean\":\n                        case \"bigint\":\n                            return String(content);\n                        default:\n                            return JSON.stringify(content);\n                    }\n                }\n\n                const message: OpenAI.ChatCompletionMessageParam = {\n                    role: \"tool\",\n                    content: contentToString(content),\n                    tool_call_id: toolCall.id\n                }\n                await this.updateConversation((prev) => [...prev, message], \"toolCall\");\n            }\n            await this.setIdle();\n            if (!stop())\n                return await this.recursiveAgent(stepOptions, stop, iter + 1);\n        }\n        await this.setIdle();\n    }\n\n    private modelSettings(): ModelSettings {\n        if (!this.options.modelSettings) {\n            return {\n                model: this.#instance.options.model,\n            }\n        }\n        return this.options.modelSettings;\n    }\n\n    async json<S extends z.ZodTypeAny = z.ZodTypeAny>(query: JsonQuery<S>): Promise<JsonResult<S, TMetaData>> {\n        const { step, preferToolCalling, name, schema, strict, description, ignoreUserMessageEvents, ...message } = query;\n        let _step = { ...step };\n        void step;\n        let _message: Omit<ChatCompletionUserMessageParam, \"role\">;\n        if (!this.registeredEvents.handleUserMessage || ignoreUserMessageEvents)\n            _message = message;\n        else\n            _message = await this.registeredEvents.handleUserMessage(message);\n        await this.updateConversation((prev) => [...prev, stripUserMessageMeta({ role: \"user\", ..._message })], \"userMessage\");\n        if (preferToolCalling) {\n\n        } else {\n            if (!_step?.modelSettings)\n                _step[\"modelSettings\"] = { ...this.modelSettings() }\n            let jsonSchema = zodToJsonSchema(schema);\n            _step.modelSettings.response_format = {\n                type: \"json_schema\", json_schema: {\n                    name,\n                    description,\n                    strict,\n                    schema: jsonSchema,\n                }\n            }\n        }\n        const state = await this.step(_step);\n        const lastAiMessage = this.lastAiMessage(state.conversation);\n        if (!lastAiMessage)\n            throw new JsonModeError(`Expected last index of conversation to be of role 'assistant'`);\n        if (typeof lastAiMessage.content != 'string') {\n            throw new JsonModeError(`Expected content of model response to be of type 'string', received '${typeof lastAiMessage.content}'`);\n        }\n        let jsonParsed: Object | undefined;\n        try {\n            jsonParsed = JSON.parse(lastAiMessage.content);\n            const parsed = schema.safeParse(jsonParsed);\n            return { ...parsed, state };\n        } catch (e) {\n            console.error(e);\n            throw new JsonModeError(`JSON.parse() of model response failed: `);\n        }\n    }\n\n    async userMessage(query: UserMessageQuery): Promise<AgentState> {\n        const { step, ...message } = query;\n        void step;\n        let _message: Omit<ChatCompletionUserMessageParam, \"role\">;\n        let error: any | undefined = undefined;\n        if (!this.registeredEvents.handleUserMessage)\n            _message = message;\n        else {\n            try {\n            _message = await this.registeredEvents.handleUserMessage(message);\n            } catch(e) {\n                error = e;\n            }\n        }\n        if (error)\n            throw error;\n        await this.updateConversation((prev) => [...prev, stripUserMessageMeta({ role: \"user\", ..._message })], \"userMessage\");\n        return await this.step(query.step);\n    }\n\n    private async applyEvents<TEventId extends AgentEventId>(eventId: TEventId, _params: applyEventParams<TEventId> | null): Promise<ReturnType<eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>>> {\n        const events = this.registeredEvents.get(eventId);\n        type EventDefaultType = EventDefaultCallback<TMetaData, TGlobalStore, TStore>;\n        if (!events)\n            return undefined as ReturnType<eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>>;\n        for (let i = 0; i < events.length; i++) {\n            const callback = events[i].callback;\n            const defaultParams: Parameters<EventDefaultType> = [this.createAgentContext()];\n            switch (eventId) {\n                case \"after:stateUpdate\": {\n                    const params: Parameters<EventDefaultType> = defaultParams;\n                    if (isAsyncFunction(callback)) {\n                        return await (callback as EventDefaultType)(...params) as any;\n                    } else {\n                        return (callback as EventDefaultType)(...params) as any;\n                    }\n                }\n                case \"after:conversationUpdate\": {\n                    type callbackType = EventAfterConversationUpdate<TMetaData, TGlobalStore, TStore>;\n                    const params: Parameters<callbackType> = [_params!.reason, ...defaultParams];\n                    if (isAsyncFunction(callback)) {\n                        return await (callback as callbackType)(...params) as any;\n                    } else {\n                        return (callback as callbackType)(...params) as any;\n                    }\n                }\n                default: {\n                    throw new FragolaError(`Internal error: event with name '${eventId}' is unknown`)\n                }\n            }\n        }\n        return undefined as ReturnType<eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>>;\n    }\n\n    /**\n     * Register a handler for a given event id.\n     * Returns an unsubscribe function that removes the registered handler.\n     *\n     * @example\n     * // listen to userMessage events\n     * const off = agent.on('userMessage', (message, context) => {\n     *   // inspect or transform the message\n     *   return { ...message, content: message.content.trim() };\n     * });\n     * // later\n     * off();\n     */\n    on<TEventId extends AgentEventId>(eventId: TEventId, callback: eventIdToCallback<TEventId, TMetaData, TGlobalStore, TStore>\n    ) {\n        type EventTargetType = registeredEvent<TEventId, TMetaData, TGlobalStore, TStore>;\n        const events = this.registeredEvents.get(eventId) || [] as EventTargetType[];\n        const id = nanoid();\n        events.push({\n            id,\n            callback: callback\n        });\n        this.registeredEvents.set(eventId, events);\n\n        return () => {\n            let events = this.registeredEvents.get(eventId);\n            if (!events)\n                return;\n            events = events.filter(event => event.id != id);\n            if (!events.length)\n                this.registeredEvents.delete(eventId);\n            else\n                this.registeredEvents.set(eventId, events);\n        }\n    }\n\n    /**\n     * Register a tool call event handler.\n     *\n     * This handler is invoked when the agent needs to execute a tool. Handlers may return a value\n     * that will be used as the tool result.\n     *\n     * @example\n     * // simple tool handler that returns an object as result\n     * agent.onToolCall(async (params, tool, context) => {\n     *   // dynamic tools do not have a handler function, so we skip them\n     *   if (params.handler == \"dynamic\") return skip();\n     *   // do something with params and tool\n     *   try {\n     *      const result = await tool.handler(params);\n     *      return { sucess: true, result }\n     * } catch(e) {\n     *      if (e extends Error)\n     *      return { error: e.message }\n     * }\n     * });\n     */\n    onToolCall<TParams = Record<any, any>>(callback: EventToolCall<TParams, TMetaData, TGlobalStore, TStore>) { return this.on(\"toolCall\", callback) }\n\n    /**\n     * Register a handler that runs after the conversation is updated.\n     *\n     * After-event handlers do not return a value. Use these to persist state, emit metrics or side-effects.\n     *\n     * @example\n     * agent.onAfterConversationUpdate((reason, context) => {\n     *   // persist conversation to a DB or telemetry\n     *   console.log('conversation updated because of', reason);\n     *   context.getStore()?.value.lastSaved = Date.now();\n     * });\n     */\n    onAfterConversationUpdate(callback: EventAfterConversationUpdate<TMetaData, TGlobalStore, TStore>) { return this.on(\"after:conversationUpdate\", callback) }\n\n    /**\n     * Register an AI message event handler.\n     *\n     * Called when an assistant message is generated or streaming. Handlers may return a modified\n     * message which will replace the message in the conversation.\n     *\n     * @example\n     * agent.onAiMessage((message, isPartial, context) => {\n     *   if (!isPartial && message.content.includes('debug')) {\n     *     // modify final assistant message\n     *      message.content += '(edited)';\n     *   }\n     *   return message;\n     * });\n     */\n    onAiMessage(callback: EventAiMessage<TMetaData, TGlobalStore, TStore>) { return this.on(\"aiMessage\", callback) }\n\n    /**\n     * Register a user message event handler.\n     *\n     * Called when a user message is appended to the conversation. Handlers may return a modified\n     * user message which will be used instead of the original.\n     *\n     * @example\n     * agent.onUserMessage((message, context) => {\n     *   // enrich user message with metadata\n     *   return { ...message, content: message.content.trim() };\n     * });\n     */\n    onUserMessage(callback: EventUserMessage<TMetaData, TGlobalStore, TStore>) { return this.on(\"userMessage\", callback) }\n\n    /**\n     * Register a model invocation event handler.\n     *\n     * This handler wraps the model call. It receives a `callAPI` function to perform the request and\n     * can return a modified assistant message. Handlers can also provide a `processChunk` function to\n     * edit streaming chunks before they are applied to the partial assistant message.\n     *\n     * @example\n     * // modify streaming chunks before they are applied\n     * agent.onModelInvocation(async (callAPI, context) => {\n     *   const processChunk: CallAPIProcessChuck = (chunk, partial) => {\n     *     // e.g. redact sensitive tokens or append extra tokens\n     *     chunck.choices[0].delta.content = '(modified)';\n     *     // perform modifications on `modified` here\n     *     return chunck;\n     *   };\n     *   // pass the processor to callAPI; it returns the final assistant message\n     *   const aiMsg = await callAPI(processChunk);\n     *   // post-process the final assistant message if needed\n     *   return { ...aiMsg, content: aiMsg.content + '\\n\\n(checked)' };\n     * });\n     */\n    onModelInvocation(callback: EventModelInvocation<TMetaData, TGlobalStore, TStore>) { return this.on(\"modelInvocation\", callback) }\n\n    /**\n     * Register a handler that runs after the agent state is updated.\n     *\n     * After-state-update handlers do not return a value. Use these for side-effects such as metrics\n     * or asynchronous persistence.\n     *\n     * @example\n     * agent.onAfterStateUpdate((context) => {\n     *   // e.g. emit metrics about step count\n     *   console.log('stepCount', context.state.stepCount);\n     * });\n     */\n    onAfterStateUpdate(callback: AfterStateUpdateCallback<TMetaData, TGlobalStore, TStore>) { return this.on(\"after:stateUpdate\", callback) };\n\n    /**\n     * Attach a hook to this agent.\n     *\n     * Hooks receive the agent instance and may register event handlers\n     * or otherwise augment the agent's behavior.\n     *\n     * @param hook - A FragolaHook to attach to the agent\n     * @returns The agent instance (chainable)\n     *\n     * @example\n     * ```ts\n     * import { fileSystemSave } from \"@src/hookPreset\";\n     * const agent = fragola.agent({...}).use(fileSystemSave(\"./testHook\"));\n     * // agent is returned so additional configuration/calls can be chained\n     * ```\n     */\n    use(hook: FragolaHook) {\n        hook(this as AgentAny);\n        this.hooks.push(hook);\n        return this;\n    }\n}\n\nexport type AgentAny = Agent<any, any, any>;"],
  "mappings": "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",
  "names": ["createStore", "stripUserMessageMeta", "streamChunkToMessage", "isAsyncFunction", "isSkipEvent", "skipEventFallback", "BadUsage", "FragolaError", "JsonModeError", "MaxStepHitError", "OpenAI", "nanoid", "EventMap", "zodToJsonSchema", "defaultStepOptions", "AGENT_FRIEND", "AgentContext", "_state", "_options", "_store", "_globalStore", "instance", "setInstructionsFn", "setOptionsFn", "stopFn", "raw", "#instance", "#raw", "newState", "newOptions", "instructions", "options", "FORK_FRIEND", "Agent", "opts", "globalStore", "openai", "forkOf", "state", "#id", "#state", "#forkOf", "map", "clonedOpts", "clonedState", "forked", "hook", "forkedRegisteredEvents", "mergedEntries", "k", "v", "e", "existing", "key", "existingIds", "toAdd", "ev", "cloneRegisteredEvents", "result", "tool", "messages", "replaceLast", "reason", "prev", "callback", "stepOptions", "maxStep", "stepParams", "overrideStepOptions", "by", "rest", "params", "conversation", "i", "msg", "args", "value", "stop", "iter", "lastMessage", "aiMessage", "lastAiMessage", "toolCalls", "toolCall", "message", "EmodelInvocation", "defaultProcessChunck", "chunck", "defaultModelSettings", "callAPI", "processChunck", "modelSettings", "clientOpts", "_processChunck", "_modelSettings", "role", "requestBody", "response", "partialMessage", "_chunck", "updateReason", "partialMessageFinal", "event", "paramsParsed", "toolCallEvents", "content", "eventProcessing", "_event", "query", "step", "preferToolCalling", "name", "schema", "strict", "description", "ignoreUserMessageEvents", "_step", "_message", "jsonSchema", "jsonParsed", "error", "eventId", "_params", "events", "defaultParams", "id"]
}
