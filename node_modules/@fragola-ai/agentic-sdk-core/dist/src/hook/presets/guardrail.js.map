{
  "version": 3,
  "sources": ["../../../../src/hook/presets/guardrail.ts"],
  "sourcesContent": ["import { FragolaError } from \"@src/exceptions\";\nimport type OpenAI from \"openai\";\nimport type { FragolaHook } from \"..\";\nimport type { AgentContext } from \"@src/agent\";\nimport type { maybePromise } from \"@src/types\";\n\n// Guardrail\nconst SYM_GUARDRAIL_FAIL = Symbol(\"Guardrail_fail\");\nconst _GuardRailFail = { message: \"\", [SYM_GUARDRAIL_FAIL]: true }\nexport type GuardRailFailType = typeof _GuardRailFail;\nexport const fail = (message: string) => ({ ..._GuardRailFail, message });\nexport type Guardrail = (fail: (message: string) => GuardRailFailType, userMessage: OpenAI.ChatCompletionUserMessageParam, context: AgentContext) => maybePromise<void | GuardRailFailType>;\nexport type GuardRailMeta = {\n    guardrail: {\n        /** Wether the user message passed the guardrail tests*/\n        rejected: true,\n        /** The name of the guardrail */\n        guard: string,\n        /** The rejection message */\n        reason: string,\n    } | {\n        rejected: false,\n    }\n};\n\nexport class GuardrailConstrain extends FragolaError {\n    constructor(message: string, guardrailName: string) {\n        super(message);\n        this.cause = guardrailName;\n        this.name = \"GuardrailConstrain\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, GuardrailConstrain)\n        }\n    }\n}\n\nexport const guardrail = (guardrails: Guardrail[], rejectionBehaviour: \"keepAndAnnotate\" | \"remove\" = \"keepAndAnnotate\"): FragolaHook => {\n    return (agent) => {\n        agent.onUserMessage(async (message, context) => {\n            // If the last message is from a user role but has been rejected by a guardrail, we remove it from the conversation\n            const lastMessage = context.state.conversation.at(-1);\n            if (lastMessage?.role == \"user\") {\n                const meta = lastMessage.meta as GuardRailMeta | undefined;\n                if (meta?.guardrail.rejected) {\n                    await context.raw.updateConversation((prev) => (prev.slice(0, -1)), \"remove:userMessage\")\n                }\n            }\n            // We test the user message against the guardrail array\n            for (const guard of guardrails) {\n                const response = await guard(fail, message, context);\n                if (response && typeof response === 'object' && 'message' in response && response[SYM_GUARDRAIL_FAIL]) {\n                    await context.stop();\n                    if (rejectionBehaviour == \"keepAndAnnotate\") {\n                        const meta: GuardRailMeta = {\n                            guardrail: {\n                                rejected: true,\n                                guard: guard.name,\n                                reason: response.message\n                            }\n                        }\n                        if (!message[\"meta\"]) {\n                            message[\"meta\"] = meta;\n                        } else {\n                            message.meta = {\n                                ...message.meta,\n                                ...meta\n                            }\n                        }\n                    context.raw.appendMessages([message], false, \"userMessage\");\n                    } else if (rejectionBehaviour == \"remove\")\n                    { /** no-op (message return won't be reached because we throw an error) */ }\n                    throw new GuardrailConstrain(response.message, guard.name);\n                }\n            }\n            return message;\n        });\n    }\n};"],
  "mappings": "AAAA,OAAS,gBAAAA,MAAoB,kBAO7B,MAAMC,EAAqB,OAAO,gBAAgB,EAC5CC,EAAiB,CAAE,QAAS,GAAI,CAACD,CAAkB,EAAG,EAAK,EAEpDE,EAAQC,IAAqB,CAAE,GAAGF,EAAgB,QAAAE,CAAQ,GAehE,MAAMC,UAA2BL,CAAa,CACjD,YAAYI,EAAiBE,EAAuB,CAChD,MAAMF,CAAO,EACb,KAAK,MAAQE,EACb,KAAK,KAAO,qBACR,MAAM,mBACN,MAAM,kBAAkB,KAAMD,CAAkB,CAExD,CACJ,CAEO,MAAME,EAAY,CAACC,EAAyBC,EAAmD,oBAC1FC,GAAU,CACdA,EAAM,cAAc,MAAON,EAASO,IAAY,CAE5C,MAAMC,EAAcD,EAAQ,MAAM,aAAa,GAAG,EAAE,EAChDC,GAAa,MAAQ,QACRA,EAAY,MACf,UAAU,UAChB,MAAMD,EAAQ,IAAI,mBAAoBE,GAAUA,EAAK,MAAM,EAAG,EAAE,EAAI,oBAAoB,EAIhG,UAAWC,KAASN,EAAY,CAC5B,MAAMO,EAAW,MAAMD,EAAMX,EAAMC,EAASO,CAAO,EACnD,GAAII,GAAY,OAAOA,GAAa,UAAY,YAAaA,GAAYA,EAASd,CAAkB,EAAG,CAEnG,GADA,MAAMU,EAAQ,KAAK,EACfF,GAAsB,kBAAmB,CACzC,MAAMO,EAAsB,CACxB,UAAW,CACP,SAAU,GACV,MAAOF,EAAM,KACb,OAAQC,EAAS,OACrB,CACJ,EACKX,EAAQ,KAGTA,EAAQ,KAAO,CACX,GAAGA,EAAQ,KACX,GAAGY,CACP,EALAZ,EAAQ,KAAUY,EAO1BL,EAAQ,IAAI,eAAe,CAACP,CAAO,EAAG,GAAO,aAAa,CAC1D,MAAWK,GAAsB,SAEjC,MAAM,IAAIJ,EAAmBU,EAAS,QAASD,EAAM,IAAI,CAC7D,CACJ,CACA,OAAOV,CACX,CAAC,CACL",
  "names": ["FragolaError", "SYM_GUARDRAIL_FAIL", "_GuardRailFail", "fail", "message", "GuardrailConstrain", "guardrailName", "guardrail", "guardrails", "rejectionBehaviour", "agent", "context", "lastMessage", "prev", "guard", "response", "meta"]
}
