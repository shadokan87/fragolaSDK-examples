{
  "version": 3,
  "sources": ["../../../../src/hook/presets/orchestration.ts"],
  "sourcesContent": ["import { type AgentAny } from \"@src/agent\";\nimport type { FragolaHook } from \"..\";\nimport type { UserMessageQuery } from \"@src/agent\";\nimport type { maybePromise } from \"@src/types\";\nimport { FragolaError } from \"@src/exceptions\";\nimport { Prompt } from \"@fragola-ai/prompt\";\nimport z from \"zod\";\nimport { tool } from \"@src/fragola\";\nimport { conversationUtils } from \"@src/stateUtils\";\n\nexport namespace OrchestrationType {\n    export type participants = AgentAny[];\n    export type flowValue = {\n        to: participants[0] | \"*\",\n        bidirectional?: boolean\n    }\n    // Flow keyed by Agent instance; Record<> cannot use objects as keys\n    export type flow = [AgentAny, flowValue][];\n    export type config = {\n        participants: participants,\n        flow: flow,\n        onMessage?: (source: AgentAny, dest: AgentAny, message: UserMessageQuery, reject: (reason: string) => string) => maybePromise<string | UserMessageQuery>\n    }\n}\n\nexport type OrchestrationBuilder = (lead: AgentAny) => OrchestrationType.config;\n\nexport class OrchestrationBadConfig extends FragolaError {\n    constructor(message: string, cause: string) {\n        super(message);\n        this.cause = cause;\n        this.name = \"OrchestrationBadConfig\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, OrchestrationBadConfig)\n        }\n    }\n}\n\nexport const orchestration = (build: OrchestrationBuilder): FragolaHook => {\n    return (lead) => {\n        // 3) Build the orchestration config from the lead agent\n        const { participants, flow, onMessage } = build(lead as AgentAny);\n\n        // Basic sanity checks (dev-time guardrails; no heavy logic here)\n        // These are optional and can be removed if undesired\n        if (!Array.isArray(participants)) {\n            console.warn(\"orchestration: 'participants' should be an array of Agent instances\");\n        }\n        // participants duplicate\n        {\n            if (new Set(participants.map(p => p.id)).size != participants.length) {\n                throw new OrchestrationBadConfig(`Participants cannot have duplicates`, \"participants_duplicate\");\n            }\n        }\n        findUnusedParticipants: {\n            let participantsIds = participants.map(p => p.id);\n            for (const [k, v] of flow) {\n                if (v.to == \"*\") {\n                    participantsIds = [];\n                    break findUnusedParticipants;\n                }\n                if (participantsIds.includes(k.id)) {\n                    participantsIds = participantsIds.filter(p => p != k.id);\n                }\n                if (participantsIds.includes(v.to.id)) {\n                    //@ts-ignore\n                    participantsIds = participantsIds.filter(p => p != v.to.id);\n                }\n            }\n            if (participantsIds.length != 0) {\n                throw new OrchestrationBadConfig(`All participants must be used in the flow, directly or by using a wildcard. Unused participants: ${JSON.stringify(participants.filter(p => participantsIds.includes(p.id)).map(p => (({ name: p.options.name + (p.id == lead.id ? ' (lead)' : ''), id: p.id }))), null, 2)}`, \"declared_but_unused_participants\");\n            }\n        }\n        // system prompt injection\n        {\n            const communicationMap: Map<AgentAny, OrchestrationType.flowValue[]> = new Map();\n            // k = agent source, v = flowValue (agent dest or wildcard with options)\n            for (const [k, v] of flow) {\n                let arr = communicationMap.get(k) || [];\n                //  we use an array to store flowValue because it is possible v.to is a wildcard\n                let _v: OrchestrationType.flowValue[] = [];\n\n                // if the flow value's 'to' is a wildcard, we retrieve the other agents to set them as destination in _v array\n                if (v.to === \"*\") {\n                    // lead -> all others\n                    _v = participants.filter(p => p.id != k.id).map(p => ({ to: p }));\n                    // all others -> lead (bidirectional)\n                    if (v.bidirectional) {\n                        for (const p of participants) {\n                            if (p.id !== k.id) {\n                                const arr2 = communicationMap.get(p) || [];\n                                arr2.push({ to: k }); // p -> lead\n                                communicationMap.set(p, arr2);\n                            }\n                        }\n                    }\n                } else {\n                    _v = [v];\n                    if (v.bidirectional) {\n                        const arr2 = communicationMap.get(v.to) || [];\n                        arr2.push({ to: k });\n                        communicationMap.set(v.to, arr2)\n                    }\n                }\n                arr = [...arr, ..._v];\n                communicationMap.set(k, arr);\n            }\n            const systemPromptTemplate = `\n<orchestration>\n<instructions>You are part of a multi-agent orchestration.\nYou can send messages to other agents using the 'message_agent' tool.\nHere are the other agents you can communicate with.</instructions>\n<agents_list>{{agents_list}}\n</agents_list>\n</orchestration>`;\n            const agentToolTemplate = `\n<tool name=\"{{name}}\">\n    <description>\n        {{description}}\n    </description>\n</tool>`;\n            const agentDescriptionTemplate = `\n<agent name=\"{{name}}\" id=\"{{id}}\">\n    <description>\n    {{description}}\n    </description>\n<tools>{{tools}}\n</tools>\n</agent>`;\n            type systemPromptVariables = Record<\"agents_list\", string>;\n            type agentToolVariables = Record<\"name\" | \"description\", string>;\n            type agentDescriptionVariables = Record<\"name\" | \"description\" | \"tools\" | \"id\", string>;\n            const messageAgentSchema = z.object({\n                id: z.string().describe(\"The id of the agent\"),\n                message: z.string().describe(\"The message to send\")\n            });\n\n            for (const [k, v] of communicationMap) {\n                const agentsDescription: Prompt[] = [];\n                k.setOptions({\n                    ...k.options,\n                    tools: [...k.options.tools || [], tool({\n                        name: \"message_agent\",\n                        description: \"send a message to another agent\",\n                        schema: messageAgentSchema,\n                        handler: async (params) => {\n                            const dest: AgentAny | undefined = v.find(agent => (agent.to as AgentAny).id == params.id)?.to as AgentAny;\n                            if (!dest)\n                                return `Agent with id ${params.id} does not exist`;\n                            const userMessage = onMessage ? await onMessage(k, dest, {\n                                content: params.message\n                            }, (reason) => reason) : {\n                                content: params.message\n                            };\n\n                            if (typeof userMessage == \"string\")\n                                return `Your message request have been rejected for the following reason: ${userMessage}`;\n                            const destState = await dest.userMessage(userMessage);\n                            const finalOutput = conversationUtils(destState.conversation).finalOutput();\n                            return finalOutput ?? `Message delivered to agent with id ${params.id}. But the agent failed to produce an output (undefined) output`\n                        }\n                    })]\n                })\n\n                for (const dest of v as { to: AgentAny }[]) {\n                    const agentDescription = new Prompt(agentDescriptionTemplate, {\n                        name: dest.to.options.name,\n                        description: dest.to.options.description,\n                        id: dest.to.id,\n                        tools: dest.to.options.tools ? dest.to.options.tools.map(tool => (new Prompt(agentToolTemplate, {\n                            name: tool.name,\n                            description: tool.description\n                        } as agentToolVariables).value)).join(\"\") : \"\"\n                    } as agentDescriptionVariables);\n                    agentsDescription.push(agentDescription)\n                }\n\n                const systemPrompt: Prompt = new Prompt(systemPromptTemplate, {\n                    agents_list: agentsDescription.map(prompt => prompt.value).join(\"\")\n                } as systemPromptVariables);\n                k.setOptions({...k.options, instructions: k.options.instructions + `\\n${systemPrompt.value}`});\n            }\n            // // Convert communicationMap to array and log it\n            // const commArray = Array.from(communicationMap.entries()).map(([agent, flows]) => ({\n            //     agent: (agent.options?.name || agent.id) + (agent.id == lead.id ? \" (lead)\" : \"\"),\n            //     flows: flows.map(f => ({\n            //         to: typeof f.to === 'string' ? f.to : (f.to.options?.name || f.to.id) + (f.to.id == lead.id ? \" (lead)\" : \"\"),\n            //         bidirectional: f.bidirectional\n            //     }))\n            // }));\n            // console.log(JSON.stringify(commArray, null, 2));\n\n        }\n    };\n}\n// Participants are a list of agents (lead is typically included as the first item)\n"],
  "mappings": "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",
  "names": ["FragolaError", "Prompt", "z", "tool", "conversationUtils", "OrchestrationBadConfig", "message", "cause", "orchestration", "build", "lead", "participants", "flow", "onMessage", "p", "findUnusedParticipants", "participantsIds", "k", "v", "communicationMap", "arr", "_v", "arr2", "systemPromptTemplate", "agentToolTemplate", "agentDescriptionTemplate", "messageAgentSchema", "agentsDescription", "params", "dest", "agent", "userMessage", "reason", "destState", "agentDescription", "systemPrompt", "prompt"]
}
