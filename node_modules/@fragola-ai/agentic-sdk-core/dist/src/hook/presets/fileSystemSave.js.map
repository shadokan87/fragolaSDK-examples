{
  "version": 3,
  "sources": ["../../../../src/hook/presets/fileSystemSave.ts"],
  "sourcesContent": ["import type OpenAI from \"openai\";\nimport type { FragolaHook } from \"../\";\nimport { nanoid } from \"nanoid\";\nimport fs from \"fs/promises\";\nimport nodePath from \"path\";\nimport syncFs from \"fs\";\n\n\n/**\n * Hook that automatically saves the conversation to the file system after each update.\n * \n * The file is saved with a filename based on the first user message content. When there are conflicting\n * filenames, it will create a nonce to ensure uniqueness. e.g `<label>.json/<label>-<nonce>.json`\n * \n * @param path - The directory path where conversation files will be saved\n * @returns A hook that saves conversations as JSON files\n * \n * @example\n * ```typescript\n * import { fileSystemSave } from \"@fragola-ai/agentic-sdk-core/hook/presets\";\n * import { Fragola } from \"@fragola-ai/agentic-sdk-core\";\n * \n * const fragola = new Fragola({ ... });\n * \n * const agent = fragola.agent({\n *     name: \"assistant\",\n *     instructions: \"you are a helpful assistant\",\n *     modelSettings: {\n *         model: \"gpt-oss-120b\"\n *     }\n * }).use(fileSystemSave(\"./testHook\"));\n * \n * await agent.userMessage({content: \"say hello\"});\n * // Creates: ./testHook/say hello.json\n * \n * await agent.userMessage({content: \"say hello again\"});\n * // Updates: ./testHook/say hello.json (same file, full conversation)\n * ```\n */\nexport const fileSystemSave = (path: string): FragolaHook => {\n    return (agent) => {\n        let fullPath: string | undefined = undefined;\n\n        agent.onAfterConversationUpdate(async (reason, context) => {\n            if (reason == \"partialAiMessage\")\n                return;\n            const { conversation } = context.state;\n            let firstUserMessage: OpenAI.ChatCompletionUserMessageParam | undefined = undefined;\n            for (let i = 0; i < conversation.length; i++) {\n                if (conversation[i].role == \"user\") {\n                    firstUserMessage = conversation[i] as OpenAI.ChatCompletionUserMessageParam;\n                }\n            }\n            if (!firstUserMessage)\n                return;\n            if (!fullPath) {\n                const label = (() => {\n                    if (typeof firstUserMessage.content == \"string\") {\n                        return firstUserMessage.content.length > 10\n                            ? firstUserMessage.content.substring(0, 3) + \"...\" + firstUserMessage.content.slice(-3)\n                            : firstUserMessage.content;\n                    } else if (Array.isArray(firstUserMessage.content)) {\n                        const textContent = firstUserMessage.content\n                            .filter(item => item.type === \"text\")\n                            .map(item => item.text)\n                            .join(\" \");\n                        return textContent.length > 10\n                            ? textContent.substring(0, 3) + \"...\" + textContent.slice(-3)\n                            : textContent;\n                    }\n                    return \"<no_label>\";\n                })();\n                fullPath = nodePath.join(path, label);\n                if (syncFs.existsSync(fullPath + \".json\")) {\n                    fullPath = `${fullPath}-${nanoid()}.json`\n                } else {\n                    fullPath = `${fullPath}.json`\n                }\n            }\n            try {\n                await fs.mkdir(path, { recursive: true });\n                await fs.writeFile(fullPath, JSON.stringify(conversation, null, 2), \"utf8\");\n            } catch (err) {\n                // eslint-disable-next-line no-console\n                console.error(\"Failed to save conversation:\", err);\n            }\n        });\n    };\n}"],
  "mappings": "AAEA,OAAS,UAAAA,MAAc,SACvB,OAAOC,MAAQ,cACf,OAAOC,MAAc,OACrB,OAAOC,MAAY,KAkCZ,MAAMC,EAAkBC,GACnBC,GAAU,CACd,IAAIC,EAEJD,EAAM,0BAA0B,MAAOE,EAAQC,IAAY,CACvD,GAAID,GAAU,mBACV,OACJ,KAAM,CAAE,aAAAE,CAAa,EAAID,EAAQ,MACjC,IAAIE,EACJ,QAASC,EAAI,EAAGA,EAAIF,EAAa,OAAQE,IACjCF,EAAaE,CAAC,EAAE,MAAQ,SACxBD,EAAmBD,EAAaE,CAAC,GAGzC,GAAKD,EAEL,IAAI,CAACJ,EAAU,CACX,MAAMM,GAAS,IAAM,CACjB,GAAI,OAAOF,EAAiB,SAAW,SACnC,OAAOA,EAAiB,QAAQ,OAAS,GACnCA,EAAiB,QAAQ,UAAU,EAAG,CAAC,EAAI,MAAQA,EAAiB,QAAQ,MAAM,EAAE,EACpFA,EAAiB,QACpB,GAAI,MAAM,QAAQA,EAAiB,OAAO,EAAG,CAChD,MAAMG,EAAcH,EAAiB,QAChC,OAAOI,GAAQA,EAAK,OAAS,MAAM,EACnC,IAAIA,GAAQA,EAAK,IAAI,EACrB,KAAK,GAAG,EACb,OAAOD,EAAY,OAAS,GACtBA,EAAY,UAAU,EAAG,CAAC,EAAI,MAAQA,EAAY,MAAM,EAAE,EAC1DA,CACV,CACA,MAAO,YACX,GAAG,EACHP,EAAWL,EAAS,KAAKG,EAAMQ,CAAK,EAChCV,EAAO,WAAWI,EAAW,OAAO,EACpCA,EAAW,GAAGA,CAAQ,IAAIP,EAAO,CAAC,QAElCO,EAAW,GAAGA,CAAQ,OAE9B,CACA,GAAI,CACA,MAAMN,EAAG,MAAMI,EAAM,CAAE,UAAW,EAAK,CAAC,EACxC,MAAMJ,EAAG,UAAUM,EAAU,KAAK,UAAUG,EAAc,KAAM,CAAC,EAAG,MAAM,CAC9E,OAASM,EAAK,CAEV,QAAQ,MAAM,+BAAgCA,CAAG,CACrD,EACJ,CAAC,CACL",
  "names": ["nanoid", "fs", "nodePath", "syncFs", "fileSystemSave", "path", "agent", "fullPath", "reason", "context", "conversation", "firstUserMessage", "i", "label", "textContent", "item", "err"]
}
