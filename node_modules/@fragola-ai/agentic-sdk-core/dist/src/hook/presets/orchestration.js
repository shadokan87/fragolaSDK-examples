import"@src/agent";import{FragolaError as O}from"@src/exceptions";import{Prompt as f}from"@fragola-ai/prompt";import y from"zod";import{tool as v}from"@src/fragola";import{conversationUtils as M}from"@src/stateUtils";class m extends O{constructor(g,n){super(g),this.cause=n,this.name="OrchestrationBadConfig",Error.captureStackTrace&&Error.captureStackTrace(this,m)}}const D=w=>g=>{const{participants:n,flow:h,onMessage:A}=w(g);if(Array.isArray(n)||console.warn("orchestration: 'participants' should be an array of Agent instances"),new Set(n.map(e=>e.id)).size!=n.length)throw new m("Participants cannot have duplicates","participants_duplicate");t:{let e=n.map(s=>s.id);for(const[s,p]of h){if(p.to=="*"){e=[];break t}e.includes(s.id)&&(e=e.filter(l=>l!=s.id)),e.includes(p.to.id)&&(e=e.filter(l=>l!=p.to.id))}if(e.length!=0)throw new m(`All participants must be used in the flow, directly or by using a wildcard. Unused participants: ${JSON.stringify(n.filter(s=>e.includes(s.id)).map(s=>({name:s.options.name+(s.id==g.id?" (lead)":""),id:s.id})),null,2)}`,"declared_but_unused_participants")}{const e=new Map;for(const[o,i]of h){let a=e.get(o)||[],d=[];if(i.to==="*"){if(d=n.filter(t=>t.id!=o.id).map(t=>({to:t})),i.bidirectional){for(const t of n)if(t.id!==o.id){const r=e.get(t)||[];r.push({to:o}),e.set(t,r)}}}else if(d=[i],i.bidirectional){const t=e.get(i.to)||[];t.push({to:o}),e.set(i.to,t)}a=[...a,...d],e.set(o,a)}const s=`
<orchestration>
<instructions>You are part of a multi-agent orchestration.
You can send messages to other agents using the 'message_agent' tool.
Here are the other agents you can communicate with.</instructions>
<agents_list>{{agents_list}}
</agents_list>
</orchestration>`,p=`
<tool name="{{name}}">
    <description>
        {{description}}
    </description>
</tool>`,l=`
<agent name="{{name}}" id="{{id}}">
    <description>
    {{description}}
    </description>
<tools>{{tools}}
</tools>
</agent>`,b=y.object({id:y.string().describe("The id of the agent"),message:y.string().describe("The message to send")});for(const[o,i]of e){const a=[];o.setOptions({...o.options,tools:[...o.options.tools||[],v({name:"message_agent",description:"send a message to another agent",schema:b,handler:async t=>{const r=i.find(u=>u.to.id==t.id)?.to;if(!r)return`Agent with id ${t.id} does not exist`;const c=A?await A(o,r,{content:t.message},u=>u):{content:t.message};if(typeof c=="string")return`Your message request have been rejected for the following reason: ${c}`;const T=await r.userMessage(c);return M(T.conversation).finalOutput()??`Message delivered to agent with id ${t.id}. But the agent failed to produce an output (undefined) output`}})]});for(const t of i){const r=new f(l,{name:t.to.options.name,description:t.to.options.description,id:t.to.id,tools:t.to.options.tools?t.to.options.tools.map(c=>new f(p,{name:c.name,description:c.description}).value).join(""):""});a.push(r)}const d=new f(s,{agents_list:a.map(t=>t.value).join("")});o.setOptions({...o.options,instructions:o.options.instructions+`
${d.value}`})}}};export{m as OrchestrationBadConfig,D as orchestration};
//# sourceMappingURL=orchestration.js.map
