{
  "version": 3,
  "sources": ["../../src/utils.ts"],
  "sourcesContent": ["import type OpenAI from \"openai\";\nimport { SKIP_EVENT } from \"./event\";\n\nexport function isAsyncFunction(fn: Function): boolean {\n    return fn.constructor.name === 'AsyncFunction';\n}\n\nexport const streamChunkToMessage = (chunk: OpenAI.Chat.Completions.ChatCompletionChunk, message: Partial<OpenAI.Chat.ChatCompletionMessageParam> = {} as Partial<OpenAI.Chat.ChatCompletionMessageParam>) => {\n    const updatedMessage = structuredClone(message);\n\n    // Handle role if present in delta\n    if (chunk.choices[0].delta?.role) {\n        updatedMessage.role = chunk.choices[0].delta.role;\n    } else if (!message.role)\n        updatedMessage.role = \"assistant\";\n\n    // Handle content if present in delta\n    if (chunk.choices[0].delta?.content) {\n        updatedMessage.content = (message.content || '') + chunk.choices[0].delta.content;\n    } else if (!message.content)\n        updatedMessage.content = \"\";\n\n    // Handle tool_calls if present in delta\n    if (chunk.choices[0].delta?.tool_calls && updatedMessage.role === \"assistant\") {\n        if (!updatedMessage.tool_calls)\n            updatedMessage.tool_calls = [];\n        const toolCall = chunk.choices[0].delta.tool_calls.at(-1);\n        if (toolCall) {\n            if (toolCall.id) {\n                updatedMessage.tool_calls.push({\n                    id: toolCall.id,\n                    type: \"function\",\n                    function: {\n                        name: toolCall.function?.name || \"\",\n                        arguments: toolCall.function?.arguments || \"\"\n                    },\n                })\n            } else {\n                const lastToolCallRef = updatedMessage.tool_calls.at(-1);\n                if (lastToolCallRef && lastToolCallRef.function && toolCall.function?.arguments) {\n                    lastToolCallRef.function = {\n                        ...lastToolCallRef.function,\n                        arguments: lastToolCallRef.function.arguments + toolCall.function.arguments\n                    }\n                }\n            }\n        }\n    }\n\n    return updatedMessage;\n}\n\nexport const isSkipEvent = (data: any) => {\n    return typeof data == \"object\" && (data as any)[SKIP_EVENT] == true\n}\nexport const skipEventFallback = async <T>(data: any, fallback: () => Promise<T>): Promise<T> => {\n    if (isSkipEvent(data))\n        return await fallback();\n    return data as T;\n}"],
  "mappings": "AACA,OAAS,cAAAA,MAAkB,UAEpB,SAASC,EAAgBC,EAAuB,CACnD,OAAOA,EAAG,YAAY,OAAS,eACnC,CAEO,MAAMC,EAAuB,CAACC,EAAoDC,EAA2D,CAAC,IAAyD,CAC1M,MAAMC,EAAiB,gBAAgBD,CAAO,EAe9C,GAZID,EAAM,QAAQ,CAAC,EAAE,OAAO,KACxBE,EAAe,KAAOF,EAAM,QAAQ,CAAC,EAAE,MAAM,KACrCC,EAAQ,OAChBC,EAAe,KAAO,aAGtBF,EAAM,QAAQ,CAAC,EAAE,OAAO,QACxBE,EAAe,SAAWD,EAAQ,SAAW,IAAMD,EAAM,QAAQ,CAAC,EAAE,MAAM,QAClEC,EAAQ,UAChBC,EAAe,QAAU,IAGzBF,EAAM,QAAQ,CAAC,EAAE,OAAO,YAAcE,EAAe,OAAS,YAAa,CACtEA,EAAe,aAChBA,EAAe,WAAa,CAAC,GACjC,MAAMC,EAAWH,EAAM,QAAQ,CAAC,EAAE,MAAM,WAAW,GAAG,EAAE,EACxD,GAAIG,EACA,GAAIA,EAAS,GACTD,EAAe,WAAW,KAAK,CAC3B,GAAIC,EAAS,GACb,KAAM,WACN,SAAU,CACN,KAAMA,EAAS,UAAU,MAAQ,GACjC,UAAWA,EAAS,UAAU,WAAa,EAC/C,CACJ,CAAC,MACE,CACH,MAAMC,EAAkBF,EAAe,WAAW,GAAG,EAAE,EACnDE,GAAmBA,EAAgB,UAAYD,EAAS,UAAU,YAClEC,EAAgB,SAAW,CACvB,GAAGA,EAAgB,SACnB,UAAWA,EAAgB,SAAS,UAAYD,EAAS,SAAS,SACtE,EAER,CAER,CAEA,OAAOD,CACX,EAEaG,EAAeC,GACjB,OAAOA,GAAQ,UAAaA,EAAaV,CAAU,GAAK,GAEtDW,EAAoB,MAAUD,EAAWE,IAC9CH,EAAYC,CAAI,EACT,MAAME,EAAS,EACnBF",
  "names": ["SKIP_EVENT", "isAsyncFunction", "fn", "streamChunkToMessage", "chunk", "message", "updatedMessage", "toolCall", "lastToolCallRef", "isSkipEvent", "data", "skipEventFallback", "fallback"]
}
