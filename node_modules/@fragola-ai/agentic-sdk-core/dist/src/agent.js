import{createStore as J}from"./store";import{stripUserMessageMeta as R}from"./fragola";import{streamChunkToMessage as U,isAsyncFunction as C,isSkipEvent as L,skipEventFallback as B}from"./utils";import{BadUsage as v,FragolaError as T,JsonModeError as E,MaxStepHitError as N}from"./exceptions";import"zod";import j from"openai/index.js";import"./event";import{nanoid as _}from"nanoid";import{EventMap as G}from"./extendedJS/events/EventMap";import{zodToJsonSchema as F}from"openai/_vendor/zod-to-json-schema/zodToJsonSchema.js";const O={maxStep:10,resetStepCountAfterUserMessage:!0},P=Symbol("AgentAccess");class Z{constructor(e,s,a,n,t,r,i,g,l){this._state=e;this._options=s;this._store=a;this._globalStore=n;this.setInstructionsFn=r;this.setOptionsFn=i;this.stopFn=g;this.#t=t,this.#e=l}#e;#t;[P]={setState:e=>{this._state=e},setOptions:e=>{this._options=e}};get state(){return this._state}get options(){return this._options}get raw(){return this.#e}get store(){return this._store}get instance(){return this.#t}getStore(){return this._store?this._store:void 0}get globalStore(){return this._globalStore}getGlobalStore(){return this._store?this._store:void 0}setInstructions(e){this.setInstructionsFn(e)}setOptions(e){this.setOptionsFn(e)}async stop(){return await this.stopFn()}}const x=Symbol("fork_friend");class k{constructor(e,s=void 0,a,n=void 0,t,r=k.defaultAgentState){this.opts=e;this.globalStore=s;this.#t=_(),this.#e=r,this.#a=n,this.#s=t,this.context=this.createAgentContext(),this.openai=a,this.toolsToModelSettingsTools(),e.initialConversation!=null&&(this.#e.conversation=structuredClone(e.initialConversation)),e.stepOptions?(this.opts.stepOptions={...O,...e.stepOptions},this.validateStepOptions(this.opts.stepOptions)):this.opts.stepOptions=O}static defaultAgentState={conversation:[],stepCount:0,status:"idle"};openai;paramsTools=[];registeredEvents=new G(()=>this.context);abortController=void 0;stopRequested=!1;context;hooks=[];#e;#t;#a=void 0;#s;setRegisteredEvents=e=>{this.registeredEvents=e};[x]={setRegisteredEvents:this.setRegisteredEvents,getRegisteredEvents:()=>this.registeredEvents};get id(){return this.#t}get state(){return this.#e}fork(){const e=structuredClone(this.opts);this.opts.store&&(delete e.store,e.store=J(this.opts.store.value));const s=structuredClone(this.#e),a=new k(e,this.globalStore,this.openai,this.#t,this.#s,s);this.hooks.forEach(t=>a.use(t));const n=a[x].getRegisteredEvents();if(this.registeredEvents.size!==0){const t=[];for(const[i,g]of n.entries())t.push([i,g.map(l=>({...l}))]);for(const[i,g]of this.registeredEvents.entries()){const l=t.find(([o])=>o===i);if(l){const o=new Set(l[1].map(d=>d.id)),c=g.filter(d=>!o.has(d.id)).map(d=>({...d}));l[1].push(...c)}else t.push([i,g.map(o=>({...o}))])}const r=new G(()=>a.context,t);a[x].setRegisteredEvents(r)}return a}toolsToModelSettingsTools(){const e=[];this.opts.tools?.forEach(s=>{e.push({type:"function",function:{name:s.name,description:s.description,parameters:s.schema?F(s.schema):void 0}})}),this.paramsTools=e}async appendMessages(e,s=!1,a){await this.updateConversation(n=>s?[...n.slice(0,-1),...e]:[...n,...e],a)}async setIdle(){await this.updateState(e=>({...e,status:"idle"}))}async setGenerating(){await this.updateState(e=>({...e,status:"generating"}))}async setWaiting(){await this.updateState(e=>({...e,status:"waiting"}))}async updateState(e){this.#e=e(this.#e),this.context[P].setState(this.#e),await this.applyEvents("after:stateUpdate",null)}async updateConversation(e,s){await this.updateState(a=>({...a,conversation:e(this.#e.conversation)})),await this.applyEvents("after:conversationUpdate",{reason:s})}setOptions(e){if(this.#e.status!=="idle")throw new v(`Cannot change options while agent is '${this.#e.status}'. Options can only be changed when agent status is 'idle'.`);this.opts={...this.opts,...e},this.context[P].setOptions({...this.context.options,...e}),this.toolsToModelSettingsTools()}get options(){return this.opts}stepOptions(){return this.opts.stepOptions}validateStepOptions(e){if(!e)return;const{maxStep:s}=e;if(s!=null&&s<=0)throw new v(`field 'maxStep' of 'StepOptions' cannot be less than or equal to 0. Received '${s}'`)}async step(e){this.stopRequested&&(this.abortController=void 0,this.stopRequested=!1);let s;if(e){const{by:n,...t}=e;if(n!=null&&n<=0)throw new v(`field 'by' of 'stepParams' cannot be less than or equal to 0. Received '${n}'`);(!t||Object.keys(t).length!=0)&&(s=t)}s&&this.validateStepOptions(s);const a=s?{...O,...s}:this.stepOptions();return this.#e.conversation.length!=0&&await this.recursiveAgent(a,()=>e?.by!=null?this.#e.stepCount==this.#e.stepCount+e.by:!1).finally(()=>{this.abortController=void 0,this.stopRequested=!1}),this.#e}resetStepCount(){this.#e.stepCount=0}reset(e={initialConversation:[]}){if(this.#e.status!="idle")throw new v(`Cannot reset while agent is '${this.#e.status}'. Agent can only be reset when agent status is 'idle'.`);this.updateState(()=>({status:"idle",conversation:e.initialConversation,stepCount:0}))}async stop(){this.stopRequested=!0,this.abortController&&this.abortController.abort()}lastAiMessage(e){for(let s=e.length-1;s>=0;s--){const a=e[s];if(a.role==="assistant")return a}}createAgentContext(){return new Z(this.#e,this.opts,this.opts.store,this.globalStore,this.#s,e=>{this.opts.instructions=e},e=>{this.opts={...e,name:this.opts.name,store:this.opts.store}},async()=>await this.stop(),{appendMessages:(...e)=>this.appendMessages(...e),updateConversation:(...e)=>this.updateConversation(...e)})}setStepCount(e){this.updateState(s=>({...s,stepCount:e}))}async recursiveAgent(e,s,a=0){if(this.stopRequested)return;if(e.resetStepCountAfterUserMessage&&this.#e.conversation.at(-1)?.role=="user"&&this.setStepCount(0),this.#e.stepCount==e.maxStep)throw new N("");this.abortController=new AbortController;const n=this.#e.conversation.at(-1);let t,r,i=[];if((()=>{if(n?.role=="user")return!0;if(n?.role=="tool"){if(r=this.lastAiMessage(this.#e.conversation),!r)throw new T("Invalid conversation, found 'tool' role without previous 'assistant' role.");if(!r.tool_calls)throw new T("Invalid conversation, found 'tool' role but 'tool_calls' is empty in previous 'assistant' role.");return i=r.tool_calls.filter(l=>!this.#e.conversation.some(o=>o.role=="tool"&&o.tool_call_id==l.id)),i.length==0}return!1})()){const l=this.registeredEvents.get("modelInvocation"),o=u=>u,c=e.modelSettings??this.modelSettings(),d=async(u,m,h)=>{const p=u||o,S=m||c,y=h?new j(h):this.openai,z=this.opts.useDeveloperRole?"developer":"system",D={...S,messages:[{role:z,content:this.opts.instructions},...this.#e.conversation]};this.paramsTools?.length&&(D.tools=this.paramsTools),this.setGenerating();const M=await y.chat.completions.create(D,{signal:this.abortController.signal});if(Symbol.asyncIterator in M){let f={},A=!1;for await(const b of M){if(p.constructor.name=="AsyncFunction"){const w=await p(b,f);f=U(w,f)}else{const w=p(b,f);f=U(w,f)}const I=b.choices[0].finish_reason?"AiMessage":"partialAiMessage",q=await this.registeredEvents.handleAiMessage(f,I=="partialAiMessage");await this.appendMessages([q],A,I),A||this.setStepCount(this.#e.stepCount+1),A=!0}this.abortController=void 0,t=f}else this.abortController=void 0,t=M.choices[0].message,await this.appendMessages([t],!1,"AiMessage"),this.setStepCount(this.#e.stepCount+1);return t.role=="assistant"&&t.tool_calls&&t.tool_calls.length&&(i=t.tool_calls),t};if(l)for(const u of l){const m=[d,this.context],h=u.callback;t=await B(await h(...m),d)}else await d()}else n?.role=="assistant"&&n.tool_calls&&n.tool_calls.length&&(i=n.tool_calls);if(i.length>0){await this.setWaiting();for(const l of i){if(this.stopRequested)break;const o=this.opts.tools?.find(p=>p.name==l.function.name);if(!o)throw new T(`Tool ${l.function.name} missing`);let c;if(o.schema&&(c=o.schema.safeParse(JSON.parse(l.function.arguments)),!c.success))throw new T("Tool arguments parsing fail");const d=this.registeredEvents.get("toolCall"),u=await(async()=>{e:{if(!d){if(o.handler=="dynamic")throw new v("Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result.");break e}for(let p=0;p<d.length;p++){const S=d[p],y=C(S.callback)?await S.callback(c?.data,o,this.context):S.callback(c?.data,o,this.context);if(!L(y))return y}if(o.handler=="dynamic")throw new v("Tools with dynamic handlers must have at least 1 'toolCall' event that produces a result. (one or more events were found but returned 'skip')")}return C(o.handler)?await o.handler(c?.data,this.context):o.handler(c?.data,this.context)})(),h={role:"tool",content:(p=>{switch(typeof p){case"string":return p;case"function":return p.toString();case"undefined":case"number":case"boolean":case"bigint":return String(p);default:return JSON.stringify(p)}})(u),tool_call_id:l.id};await this.updateConversation(p=>[...p,h],"toolCall")}if(await this.setIdle(),!s())return await this.recursiveAgent(e,s,a+1)}await this.setIdle()}modelSettings(){return this.options.modelSettings?this.options.modelSettings:{model:this.#s.options.model}}async json(e){const{step:s,preferToolCalling:a,name:n,schema:t,strict:r,description:i,ignoreUserMessageEvents:g,...l}=e;let o={...s},c;if(!this.registeredEvents.handleUserMessage||g?c=l:c=await this.registeredEvents.handleUserMessage(l),await this.updateConversation(h=>[...h,R({role:"user",...c})],"userMessage"),!a){o?.modelSettings||(o.modelSettings={...this.modelSettings()});let h=F(t);o.modelSettings.response_format={type:"json_schema",json_schema:{name:n,description:i,strict:r,schema:h}}}const d=await this.step(o),u=this.lastAiMessage(d.conversation);if(!u)throw new E("Expected last index of conversation to be of role 'assistant'");if(typeof u.content!="string")throw new E(`Expected content of model response to be of type 'string', received '${typeof u.content}'`);let m;try{return m=JSON.parse(u.content),{...t.safeParse(m),state:d}}catch(h){throw console.error(h),new E("JSON.parse() of model response failed: ")}}async userMessage(e){const{step:s,...a}=e;let n,t;if(!this.registeredEvents.handleUserMessage)n=a;else try{n=await this.registeredEvents.handleUserMessage(a)}catch(r){t=r}if(t)throw t;return await this.updateConversation(r=>[...r,R({role:"user",...n})],"userMessage"),await this.step(e.step)}async applyEvents(e,s){const a=this.registeredEvents.get(e);if(a)for(let n=0;n<a.length;n++){const t=a[n].callback,r=[this.createAgentContext()];switch(e){case"after:stateUpdate":{const i=r;return C(t)?await t(...i):t(...i)}case"after:conversationUpdate":{const i=[s.reason,...r];return C(t)?await t(...i):t(...i)}default:throw new T(`Internal error: event with name '${e}' is unknown`)}}}on(e,s){const a=this.registeredEvents.get(e)||[],n=_();return a.push({id:n,callback:s}),this.registeredEvents.set(e,a),()=>{let t=this.registeredEvents.get(e);t&&(t=t.filter(r=>r.id!=n),t.length?this.registeredEvents.set(e,t):this.registeredEvents.delete(e))}}onToolCall(e){return this.on("toolCall",e)}onAfterConversationUpdate(e){return this.on("after:conversationUpdate",e)}onAiMessage(e){return this.on("aiMessage",e)}onUserMessage(e){return this.on("userMessage",e)}onModelInvocation(e){return this.on("modelInvocation",e)}onAfterStateUpdate(e){return this.on("after:stateUpdate",e)}use(e){return e(this),this.hooks.push(e),this}}export{k as Agent,Z as AgentContext,O as defaultStepOptions};
//# sourceMappingURL=agent.js.map
