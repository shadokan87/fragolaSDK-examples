import { readFileSync } from "fs";
import path from "path";
class MissingVariablesError extends Error {
  constructor(variables, prompt) {
    super(`Missing variables: ${variables.map((v) => `'${v}'`).join(", ")}. For prompt: ${prompt}`);
    this.variables = variables;
    this.name = "MissingVariablesError";
  }
}
class NamespaceUndefinedError extends Error {
  constructor(namespace) {
    super(`Tried to acess undefined namespace when using load() function: '${namespace}' does not exist`);
    this.namespace = namespace;
    this.name = "NamespaceUndefinedError";
  }
}
class LoadFileReadError extends Error {
  constructor(filePath, originalError) {
    super(`Failed to load prompt from ${filePath}: ${originalError.message}`);
    this.filePath = filePath;
    this.originalError = originalError;
    this.name = "LoadFileReadError";
  }
}
const load = (relativePath) => ({ load: true, relativePath });
class Prompt {
  static defaultVariableRegex = /\{\{(\s*[\w.]+\s*)\}\}/g;
  /**
   * A map of aliases to file paths for use with the {@link load} function.
   * Allows defining shortcuts for commonly used prompt file paths.
   * 
   * @example
   * ```typescript
   * Prompt.pathAlias = {
   *   browse: "prompts",      // Maps "@browse" to "prompts/"
   *   refund: "prompts/refund" // Maps "@refund" to "prompts/refund/"
   * }
   * 
   * // Usage with load():
   * load("@refund/shopRefund.md") // Resolves to "prompts/refund/shopRefund.md"
   * ```
   * @see {@link load}
   */
  static pathAlias = {};
  #originalPrompt = "";
  #value = "";
  #variableRegex = Prompt.defaultVariableRegex;
  #variables = {};
  #basePath = process.env["PWD"];
  constructor(prompt, variables = {}) {
    if (!process.env["PWD"])
      console.warn("PWD env variable not set");
    if (typeof prompt == "string") {
      this.#originalPrompt = prompt;
      this.#value = prompt;
    } else {
      this.#originalPrompt = this.#load(prompt.relativePath);
      this.#value = this.#originalPrompt;
    }
    this.setVariables(variables);
  }
  #stringify(value) {
    switch (typeof value) {
      case "object":
        return JSON.stringify(value);
      default:
        return value;
    }
  }
  #isInsideCodeBlock(index, text) {
    const codeBlockRegex = /```[\s\S]*?```/g;
    let match;
    while ((match = codeBlockRegex.exec(text)) !== null) {
      const start = match.index;
      const end = start + match[0].length;
      if (index >= start && index < end) {
        return true;
      }
    }
    return false;
  }
  /**
   * Updates the variables used for string interpolation and re-processes the prompt template.
   * 
   * @param variables - Your new variables
   * @throws {MissingVariablesError} When required variables are not provided in the variables object
   */
  setVariables(variables) {
    this.#variables = variables;
    const allMatch = Array.from(this.#originalPrompt.matchAll(this.#variableRegex)).filter((match) => !this.#isInsideCodeBlock(match.index, this.#originalPrompt)).map((match) => {
      return {
        placeholder: match[0],
        index: match.index
      };
    });
    const getVariableNameFromPlaceholder = (placeholder) => {
      return placeholder.replaceAll(/[{}]/g, "").trim();
    };
    let missingVariables = [];
    let applyReplace = [];
    allMatch.forEach((match) => {
      const variableName = getVariableNameFromPlaceholder(match.placeholder);
      if (variableName in variables)
        applyReplace.push(() => this.#value = this.#value.replace(match.placeholder, this.#stringify(this.#variables[variableName])));
      else
        missingVariables.push(variableName);
    });
    if (missingVariables.length)
      throw new MissingVariablesError(missingVariables, this.#originalPrompt);
    applyReplace.forEach((replace) => replace());
  }
  #load(relativePath) {
    let _relativePath = (() => {
      const split = relativePath.split("/");
      if (split.length > 1) {
        const namespace = split[0].trim();
        if (namespace[0] == "@") {
          const name = split[0].slice(1);
          if (name in Prompt.pathAlias) {
            return path.join(Prompt.pathAlias[name], split[1]);
          } else
            throw new NamespaceUndefinedError(namespace);
        }
      }
      return relativePath;
    })();
    let fullPath = path.join(this.#basePath || "./", _relativePath);
    if (!fullPath.split("/").at(-1)?.includes("."))
      fullPath = `${fullPath}.md`;
    try {
      const content = readFileSync(fullPath, "utf-8");
      return content;
    } catch (error) {
      if (error instanceof Error) {
        throw new LoadFileReadError(fullPath, error);
      }
      throw error;
    }
  }
  /**
   * Gets the original prompt string used for this instance. Before any processing
   * @returns {string} The original prompt string
   */
  get promptString() {
    return this.#originalPrompt;
  }
  /**
   * Gets the variables currently in use for this prompt.
   * @returns {Map<string, any>} A map containing the prompt variables and their values.
   */
  get variables() {
    return this.#variables;
  }
  /**
   * Gets the interpolated value of the prompt.
   * @returns {string} The resulting string after all variable interpolation has been applied.
   */
  get value() {
    return this.#value;
  }
}
export {
  LoadFileReadError,
  MissingVariablesError,
  NamespaceUndefinedError,
  Prompt as default,
  load
};
//# sourceMappingURL=Prompt.js.map
